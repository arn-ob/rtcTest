{"version":3,"sources":["C:/Users/Arnob/Downloads/webrtc-angularfire2-master/webrtc-angularfire2-master/angular/~/webrtc-adapter/out/adapter.js","C:/Users/Arnob/Downloads/webrtc-angularfire2-master/webrtc-angularfire2-master/angular/~/script-loader/addScript.js","C:/Users/Arnob/Downloads/webrtc-angularfire2-master/webrtc-angularfire2-master/angular/~/webrtc-adapter/out/adapter.js?faca"],"names":[],"mappings":"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","file":"scripts.bundle.js","sourcesContent":["module.exports = \"(function(f){if(typeof exports===\\\"object\\\"&&typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n /* eslint-env node */\\n'use strict';\\n\\n// SDP helpers.\\nvar SDPUtils = {};\\n\\n// Generate an alphanumeric identifier for cname or mids.\\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\\nSDPUtils.generateIdentifier = function() {\\n  return Math.random().toString(36).substr(2, 10);\\n};\\n\\n// The RTCP CNAME used by all peerconnections from the same JS.\\nSDPUtils.localCName = SDPUtils.generateIdentifier();\\n\\n// Splits SDP into lines, dealing with both CRLF and LF.\\nSDPUtils.splitLines = function(blob) {\\n  return blob.trim().split('\\\\n').map(function(line) {\\n    return line.trim();\\n  });\\n};\\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\\nSDPUtils.splitSections = function(blob) {\\n  var parts = blob.split('\\\\nm=');\\n  return parts.map(function(part, index) {\\n    return (index > 0 ? 'm=' + part : part).trim() + '\\\\r\\\\n';\\n  });\\n};\\n\\n// Returns lines that start with a certain prefix.\\nSDPUtils.matchPrefix = function(blob, prefix) {\\n  return SDPUtils.splitLines(blob).filter(function(line) {\\n    return line.indexOf(prefix) === 0;\\n  });\\n};\\n\\n// Parses an ICE candidate line. Sample input:\\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\\n// rport 55996\\\"\\nSDPUtils.parseCandidate = function(line) {\\n  var parts;\\n  // Parse both variants.\\n  if (line.indexOf('a=candidate:') === 0) {\\n    parts = line.substring(12).split(' ');\\n  } else {\\n    parts = line.substring(10).split(' ');\\n  }\\n\\n  var candidate = {\\n    foundation: parts[0],\\n    component: parseInt(parts[1], 10),\\n    protocol: parts[2].toLowerCase(),\\n    priority: parseInt(parts[3], 10),\\n    ip: parts[4],\\n    port: parseInt(parts[5], 10),\\n    // skip parts[6] == 'typ'\\n    type: parts[7]\\n  };\\n\\n  for (var i = 8; i < parts.length; i += 2) {\\n    switch (parts[i]) {\\n      case 'raddr':\\n        candidate.relatedAddress = parts[i + 1];\\n        break;\\n      case 'rport':\\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\\n        break;\\n      case 'tcptype':\\n        candidate.tcpType = parts[i + 1];\\n        break;\\n      default: // extension handling, in particular ufrag\\n        candidate[parts[i]] = parts[i + 1];\\n        break;\\n    }\\n  }\\n  return candidate;\\n};\\n\\n// Translates a candidate object into SDP candidate attribute.\\nSDPUtils.writeCandidate = function(candidate) {\\n  var sdp = [];\\n  sdp.push(candidate.foundation);\\n  sdp.push(candidate.component);\\n  sdp.push(candidate.protocol.toUpperCase());\\n  sdp.push(candidate.priority);\\n  sdp.push(candidate.ip);\\n  sdp.push(candidate.port);\\n\\n  var type = candidate.type;\\n  sdp.push('typ');\\n  sdp.push(type);\\n  if (type !== 'host' && candidate.relatedAddress &&\\n      candidate.relatedPort) {\\n    sdp.push('raddr');\\n    sdp.push(candidate.relatedAddress); // was: relAddr\\n    sdp.push('rport');\\n    sdp.push(candidate.relatedPort); // was: relPort\\n  }\\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\\n    sdp.push('tcptype');\\n    sdp.push(candidate.tcpType);\\n  }\\n  if (candidate.ufrag) {\\n    sdp.push('ufrag');\\n    sdp.push(candidate.ufrag);\\n  }\\n  return 'candidate:' + sdp.join(' ');\\n};\\n\\n// Parses an ice-options line, returns an array of option tags.\\n// a=ice-options:foo bar\\nSDPUtils.parseIceOptions = function(line) {\\n  return line.substr(14).split(' ');\\n}\\n\\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\\n// a=rtpmap:111 opus/48000/2\\nSDPUtils.parseRtpMap = function(line) {\\n  var parts = line.substr(9).split(' ');\\n  var parsed = {\\n    payloadType: parseInt(parts.shift(), 10) // was: id\\n  };\\n\\n  parts = parts[0].split('/');\\n\\n  parsed.name = parts[0];\\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\\n  // was: channels\\n  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\\n  return parsed;\\n};\\n\\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\\n// RTCRtpCodecParameters.\\nSDPUtils.writeRtpMap = function(codec) {\\n  var pt = codec.payloadType;\\n  if (codec.preferredPayloadType !== undefined) {\\n    pt = codec.preferredPayloadType;\\n  }\\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\\n      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\\\\r\\\\n';\\n};\\n\\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\\nSDPUtils.parseExtmap = function(line) {\\n  var parts = line.substr(9).split(' ');\\n  return {\\n    id: parseInt(parts[0], 10),\\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\\n    uri: parts[1]\\n  };\\n};\\n\\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\\n// RTCRtpHeaderExtension.\\nSDPUtils.writeExtmap = function(headerExtension) {\\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\\n          ? '/' + headerExtension.direction\\n          : '') +\\n      ' ' + headerExtension.uri + '\\\\r\\\\n';\\n};\\n\\n// Parses an ftmp line, returns dictionary. Sample input:\\n// a=fmtp:96 vbr=on;cng=on\\n// Also deals with vbr=on; cng=on\\nSDPUtils.parseFmtp = function(line) {\\n  var parsed = {};\\n  var kv;\\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\\n  for (var j = 0; j < parts.length; j++) {\\n    kv = parts[j].trim().split('=');\\n    parsed[kv[0].trim()] = kv[1];\\n  }\\n  return parsed;\\n};\\n\\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\\nSDPUtils.writeFmtp = function(codec) {\\n  var line = '';\\n  var pt = codec.payloadType;\\n  if (codec.preferredPayloadType !== undefined) {\\n    pt = codec.preferredPayloadType;\\n  }\\n  if (codec.parameters && Object.keys(codec.parameters).length) {\\n    var params = [];\\n    Object.keys(codec.parameters).forEach(function(param) {\\n      params.push(param + '=' + codec.parameters[param]);\\n    });\\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\\\r\\\\n';\\n  }\\n  return line;\\n};\\n\\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\\n// a=rtcp-fb:98 nack rpsi\\nSDPUtils.parseRtcpFb = function(line) {\\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\\n  return {\\n    type: parts.shift(),\\n    parameter: parts.join(' ')\\n  };\\n};\\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\\nSDPUtils.writeRtcpFb = function(codec) {\\n  var lines = '';\\n  var pt = codec.payloadType;\\n  if (codec.preferredPayloadType !== undefined) {\\n    pt = codec.preferredPayloadType;\\n  }\\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\\n    // FIXME: special handling for trr-int?\\n    codec.rtcpFeedback.forEach(function(fb) {\\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\\n          '\\\\r\\\\n';\\n    });\\n  }\\n  return lines;\\n};\\n\\n// Parses an RFC 5576 ssrc media attribute. Sample input:\\n// a=ssrc:3735928559 cname:something\\nSDPUtils.parseSsrcMedia = function(line) {\\n  var sp = line.indexOf(' ');\\n  var parts = {\\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\\n  };\\n  var colon = line.indexOf(':', sp);\\n  if (colon > -1) {\\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\\n    parts.value = line.substr(colon + 1);\\n  } else {\\n    parts.attribute = line.substr(sp + 1);\\n  }\\n  return parts;\\n};\\n\\n// Extracts the MID (RFC 5888) from a media section.\\n// returns the MID or undefined if no mid line was found.\\nSDPUtils.getMid = function(mediaSection) {\\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\\n  if (mid) {\\n    return mid.substr(6);\\n  }\\n}\\n\\nSDPUtils.parseFingerprint = function(line) {\\n  var parts = line.substr(14).split(' ');\\n  return {\\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\\n    value: parts[1]\\n  };\\n};\\n\\n// Extracts DTLS parameters from SDP media section or sessionpart.\\n// FIXME: for consistency with other functions this should only\\n//   get the fingerprint line as input. See also getIceParameters.\\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\\n      'a=fingerprint:');\\n  // Note: a=setup line is ignored since we use the 'auto' role.\\n  // Note2: 'algorithm' is not case sensitive except in Edge.\\n  return {\\n    role: 'auto',\\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\\n  };\\n};\\n\\n// Serializes DTLS parameters to SDP.\\nSDPUtils.writeDtlsParameters = function(params, setupType) {\\n  var sdp = 'a=setup:' + setupType + '\\\\r\\\\n';\\n  params.fingerprints.forEach(function(fp) {\\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\\\r\\\\n';\\n  });\\n  return sdp;\\n};\\n// Parses ICE information from SDP media section or sessionpart.\\n// FIXME: for consistency with other functions this should only\\n//   get the ice-ufrag and ice-pwd lines as input.\\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\\n  var lines = SDPUtils.splitLines(mediaSection);\\n  // Search in session part, too.\\n  lines = lines.concat(SDPUtils.splitLines(sessionpart));\\n  var iceParameters = {\\n    usernameFragment: lines.filter(function(line) {\\n      return line.indexOf('a=ice-ufrag:') === 0;\\n    })[0].substr(12),\\n    password: lines.filter(function(line) {\\n      return line.indexOf('a=ice-pwd:') === 0;\\n    })[0].substr(10)\\n  };\\n  return iceParameters;\\n};\\n\\n// Serializes ICE parameters to SDP.\\nSDPUtils.writeIceParameters = function(params) {\\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\\\r\\\\n' +\\n      'a=ice-pwd:' + params.password + '\\\\r\\\\n';\\n};\\n\\n// Parses the SDP media section and returns RTCRtpParameters.\\nSDPUtils.parseRtpParameters = function(mediaSection) {\\n  var description = {\\n    codecs: [],\\n    headerExtensions: [],\\n    fecMechanisms: [],\\n    rtcp: []\\n  };\\n  var lines = SDPUtils.splitLines(mediaSection);\\n  var mline = lines[0].split(' ');\\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\\n    var pt = mline[i];\\n    var rtpmapline = SDPUtils.matchPrefix(\\n        mediaSection, 'a=rtpmap:' + pt + ' ')[0];\\n    if (rtpmapline) {\\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\\n      var fmtps = SDPUtils.matchPrefix(\\n          mediaSection, 'a=fmtp:' + pt + ' ');\\n      // Only the first a=fmtp:<pt> is considered.\\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\\n          mediaSection, 'a=rtcp-fb:' + pt + ' ')\\n        .map(SDPUtils.parseRtcpFb);\\n      description.codecs.push(codec);\\n      // parse FEC mechanisms from rtpmap lines.\\n      switch (codec.name.toUpperCase()) {\\n        case 'RED':\\n        case 'ULPFEC':\\n          description.fecMechanisms.push(codec.name.toUpperCase());\\n          break;\\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\\n          break;\\n      }\\n    }\\n  }\\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\\n  });\\n  // FIXME: parse rtcp.\\n  return description;\\n};\\n\\n// Generates parts of the SDP media section describing the capabilities /\\n// parameters.\\nSDPUtils.writeRtpDescription = function(kind, caps) {\\n  var sdp = '';\\n\\n  // Build the mline.\\n  sdp += 'm=' + kind + ' ';\\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\\n  sdp += ' UDP/TLS/RTP/SAVPF ';\\n  sdp += caps.codecs.map(function(codec) {\\n    if (codec.preferredPayloadType !== undefined) {\\n      return codec.preferredPayloadType;\\n    }\\n    return codec.payloadType;\\n  }).join(' ') + '\\\\r\\\\n';\\n\\n  sdp += 'c=IN IP4 0.0.0.0\\\\r\\\\n';\\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\\\r\\\\n';\\n\\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\\n  caps.codecs.forEach(function(codec) {\\n    sdp += SDPUtils.writeRtpMap(codec);\\n    sdp += SDPUtils.writeFmtp(codec);\\n    sdp += SDPUtils.writeRtcpFb(codec);\\n  });\\n  var maxptime = 0;\\n  caps.codecs.forEach(function(codec) {\\n    if (codec.maxptime > maxptime) {\\n      maxptime = codec.maxptime;\\n    }\\n  });\\n  if (maxptime > 0) {\\n    sdp += 'a=maxptime:' + maxptime + '\\\\r\\\\n';\\n  }\\n  sdp += 'a=rtcp-mux\\\\r\\\\n';\\n\\n  caps.headerExtensions.forEach(function(extension) {\\n    sdp += SDPUtils.writeExtmap(extension);\\n  });\\n  // FIXME: write fecMechanisms.\\n  return sdp;\\n};\\n\\n// Parses the SDP media section and returns an array of\\n// RTCRtpEncodingParameters.\\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\\n  var encodingParameters = [];\\n  var description = SDPUtils.parseRtpParameters(mediaSection);\\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\\n\\n  // filter a=ssrc:... cname:, ignore PlanB-msid\\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\\n  .map(function(line) {\\n    return SDPUtils.parseSsrcMedia(line);\\n  })\\n  .filter(function(parts) {\\n    return parts.attribute === 'cname';\\n  });\\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\\n  var secondarySsrc;\\n\\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\\n  .map(function(line) {\\n    var parts = line.split(' ');\\n    parts.shift();\\n    return parts.map(function(part) {\\n      return parseInt(part, 10);\\n    });\\n  });\\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\\n    secondarySsrc = flows[0][1];\\n  }\\n\\n  description.codecs.forEach(function(codec) {\\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\\n      var encParam = {\\n        ssrc: primarySsrc,\\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\\n        rtx: {\\n          ssrc: secondarySsrc\\n        }\\n      };\\n      encodingParameters.push(encParam);\\n      if (hasRed) {\\n        encParam = JSON.parse(JSON.stringify(encParam));\\n        encParam.fec = {\\n          ssrc: secondarySsrc,\\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\\n        };\\n        encodingParameters.push(encParam);\\n      }\\n    }\\n  });\\n  if (encodingParameters.length === 0 && primarySsrc) {\\n    encodingParameters.push({\\n      ssrc: primarySsrc\\n    });\\n  }\\n\\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\\n  if (bandwidth.length) {\\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\\n      // use formula from JSEP to convert b=AS to TIAS value.\\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\\n          - (50 * 40 * 8);\\n    } else {\\n      bandwidth = undefined;\\n    }\\n    encodingParameters.forEach(function(params) {\\n      params.maxBitrate = bandwidth;\\n    });\\n  }\\n  return encodingParameters;\\n};\\n\\n// parses http://draft.ortc.org/#rtcrtcpparameters*\\nSDPUtils.parseRtcpParameters = function(mediaSection) {\\n  var rtcpParameters = {};\\n\\n  var cname;\\n  // Gets the first SSRC. Note that with RTX there might be multiple\\n  // SSRCs.\\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\\n      .map(function(line) {\\n        return SDPUtils.parseSsrcMedia(line);\\n      })\\n      .filter(function(obj) {\\n        return obj.attribute === 'cname';\\n      })[0];\\n  if (remoteSsrc) {\\n    rtcpParameters.cname = remoteSsrc.value;\\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\\n  }\\n\\n  // Edge uses the compound attribute instead of reducedSize\\n  // compound is !reducedSize\\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\\n  rtcpParameters.reducedSize = rsize.length > 0;\\n  rtcpParameters.compound = rsize.length === 0;\\n\\n  // parses the rtcp-mux attrіbute.\\n  // Note that Edge does not support unmuxed RTCP.\\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\\n  rtcpParameters.mux = mux.length > 0;\\n\\n  return rtcpParameters;\\n};\\n\\n// parses either a=msid: or a=ssrc:... msid lines and returns\\n// the id of the MediaStream and MediaStreamTrack.\\nSDPUtils.parseMsid = function(mediaSection) {\\n  var parts;\\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\\n  if (spec.length === 1) {\\n    parts = spec[0].substr(7).split(' ');\\n    return {stream: parts[0], track: parts[1]};\\n  }\\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\\n  .map(function(line) {\\n    return SDPUtils.parseSsrcMedia(line);\\n  })\\n  .filter(function(parts) {\\n    return parts.attribute === 'msid';\\n  });\\n  if (planB.length > 0) {\\n    parts = planB[0].value.split(' ');\\n    return {stream: parts[0], track: parts[1]};\\n  }\\n};\\n\\n// Generate a session ID for SDP.\\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\\n// recommends using a cryptographically random +ve 64-bit value\\n// but right now this should be acceptable and within the right range\\nSDPUtils.generateSessionId = function() {\\n  return Math.random().toString().substr(2, 21);\\n};\\n\\n// Write boilder plate for start of SDP\\n// sessId argument is optional - if not supplied it will\\n// be generated randomly\\nSDPUtils.writeSessionBoilerplate = function(sessId) {\\n  var sessionId;\\n  if (sessId) {\\n    sessionId = sessId;\\n  } else {\\n    sessionId = SDPUtils.generateSessionId();\\n  }\\n  // FIXME: sess-id should be an NTP timestamp.\\n  return 'v=0\\\\r\\\\n' +\\n      'o=thisisadapterortc ' + sessionId + ' 2 IN IP4 127.0.0.1\\\\r\\\\n' +\\n      's=-\\\\r\\\\n' +\\n      't=0 0\\\\r\\\\n';\\n};\\n\\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\\n\\n  // Map ICE parameters (ufrag, pwd) to SDP.\\n  sdp += SDPUtils.writeIceParameters(\\n      transceiver.iceGatherer.getLocalParameters());\\n\\n  // Map DTLS parameters to SDP.\\n  sdp += SDPUtils.writeDtlsParameters(\\n      transceiver.dtlsTransport.getLocalParameters(),\\n      type === 'offer' ? 'actpass' : 'active');\\n\\n  sdp += 'a=mid:' + transceiver.mid + '\\\\r\\\\n';\\n\\n  if (transceiver.direction) {\\n    sdp += 'a=' + transceiver.direction + '\\\\r\\\\n';\\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\\n    sdp += 'a=sendrecv\\\\r\\\\n';\\n  } else if (transceiver.rtpSender) {\\n    sdp += 'a=sendonly\\\\r\\\\n';\\n  } else if (transceiver.rtpReceiver) {\\n    sdp += 'a=recvonly\\\\r\\\\n';\\n  } else {\\n    sdp += 'a=inactive\\\\r\\\\n';\\n  }\\n\\n  if (transceiver.rtpSender) {\\n    // spec.\\n    var msid = 'msid:' + stream.id + ' ' +\\n        transceiver.rtpSender.track.id + '\\\\r\\\\n';\\n    sdp += 'a=' + msid;\\n\\n    // for Chrome.\\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\\n        ' ' + msid;\\n    if (transceiver.sendEncodingParameters[0].rtx) {\\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\\n          ' ' + msid;\\n      sdp += 'a=ssrc-group:FID ' +\\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\\n          '\\\\r\\\\n';\\n    }\\n  }\\n  // FIXME: this should be written by writeRtpDescription.\\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\\n      ' cname:' + SDPUtils.localCName + '\\\\r\\\\n';\\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\\n        ' cname:' + SDPUtils.localCName + '\\\\r\\\\n';\\n  }\\n  return sdp;\\n};\\n\\n// Gets the direction from the mediaSection or the sessionpart.\\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\\n  var lines = SDPUtils.splitLines(mediaSection);\\n  for (var i = 0; i < lines.length; i++) {\\n    switch (lines[i]) {\\n      case 'a=sendrecv':\\n      case 'a=sendonly':\\n      case 'a=recvonly':\\n      case 'a=inactive':\\n        return lines[i].substr(2);\\n      default:\\n        // FIXME: What should happen here?\\n    }\\n  }\\n  if (sessionpart) {\\n    return SDPUtils.getDirection(sessionpart);\\n  }\\n  return 'sendrecv';\\n};\\n\\nSDPUtils.getKind = function(mediaSection) {\\n  var lines = SDPUtils.splitLines(mediaSection);\\n  var mline = lines[0].split(' ');\\n  return mline[0].substr(2);\\n};\\n\\nSDPUtils.isRejected = function(mediaSection) {\\n  return mediaSection.split(' ', 2)[1] === '0';\\n};\\n\\n// Expose public methods.\\nmodule.exports = SDPUtils;\\n\\n},{}],2:[function(require,module,exports){\\n(function (global){\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n'use strict';\\n\\nvar adapterFactory = require('./adapter_factory.js');\\nmodule.exports = adapterFactory({window: global.window});\\n\\n}).call(this,typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {})\\n},{\\\"./adapter_factory.js\\\":3}],3:[function(require,module,exports){\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n'use strict';\\n\\n// Shimming starts here.\\nmodule.exports = function(dependencies, opts) {\\n  var window = dependencies && dependencies.window;\\n\\n  var options = Object.assign({\\n    shimChrome: true,\\n    shimFirefox: true,\\n    shimEdge: true,\\n    shimSafari: true,\\n  }, opts);\\n\\n  // Utils.\\n  var utils = require('./utils');\\n  var logging = utils.log;\\n  var browserDetails = utils.detectBrowser(window);\\n\\n  // Export to the adapter global object visible in the browser.\\n  var adapter = {\\n    browserDetails: browserDetails,\\n    extractVersion: utils.extractVersion,\\n    disableLog: utils.disableLog,\\n    disableWarnings: utils.disableWarnings\\n  };\\n\\n  // Uncomment the line below if you want logging to occur, including logging\\n  // for the switch statement below. Can also be turned on in the browser via\\n  // adapter.disableLog(false), but then logging from the switch statement below\\n  // will not appear.\\n  // require('./utils').disableLog(false);\\n\\n  // Browser shims.\\n  var chromeShim = require('./chrome/chrome_shim') || null;\\n  var edgeShim = require('./edge/edge_shim') || null;\\n  var firefoxShim = require('./firefox/firefox_shim') || null;\\n  var safariShim = require('./safari/safari_shim') || null;\\n\\n  // Shim browser if found.\\n  switch (browserDetails.browser) {\\n    case 'chrome':\\n      if (!chromeShim || !chromeShim.shimPeerConnection ||\\n          !options.shimChrome) {\\n        logging('Chrome shim is not included in this adapter release.');\\n        return adapter;\\n      }\\n      logging('adapter.js shimming chrome.');\\n      // Export to the adapter global object visible in the browser.\\n      adapter.browserShim = chromeShim;\\n\\n      chromeShim.shimGetUserMedia(window);\\n      chromeShim.shimMediaStream(window);\\n      utils.shimCreateObjectURL(window);\\n      chromeShim.shimSourceObject(window);\\n      chromeShim.shimPeerConnection(window);\\n      chromeShim.shimOnTrack(window);\\n      chromeShim.shimAddTrack(window);\\n      chromeShim.shimGetSendersWithDtmf(window);\\n      break;\\n    case 'firefox':\\n      if (!firefoxShim || !firefoxShim.shimPeerConnection ||\\n          !options.shimFirefox) {\\n        logging('Firefox shim is not included in this adapter release.');\\n        return adapter;\\n      }\\n      logging('adapter.js shimming firefox.');\\n      // Export to the adapter global object visible in the browser.\\n      adapter.browserShim = firefoxShim;\\n\\n      firefoxShim.shimGetUserMedia(window);\\n      utils.shimCreateObjectURL(window);\\n      firefoxShim.shimSourceObject(window);\\n      firefoxShim.shimPeerConnection(window);\\n      firefoxShim.shimOnTrack(window);\\n      break;\\n    case 'edge':\\n      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {\\n        logging('MS edge shim is not included in this adapter release.');\\n        return adapter;\\n      }\\n      logging('adapter.js shimming edge.');\\n      // Export to the adapter global object visible in the browser.\\n      adapter.browserShim = edgeShim;\\n\\n      edgeShim.shimGetUserMedia(window);\\n      utils.shimCreateObjectURL(window);\\n      edgeShim.shimPeerConnection(window);\\n      edgeShim.shimReplaceTrack(window);\\n      break;\\n    case 'safari':\\n      if (!safariShim || !options.shimSafari) {\\n        logging('Safari shim is not included in this adapter release.');\\n        return adapter;\\n      }\\n      logging('adapter.js shimming safari.');\\n      // Export to the adapter global object visible in the browser.\\n      adapter.browserShim = safariShim;\\n      // shim window.URL.createObjectURL Safari (technical preview)\\n      utils.shimCreateObjectURL(window);\\n      safariShim.shimRTCIceServerUrls(window);\\n      safariShim.shimCallbacksAPI(window);\\n      safariShim.shimLocalStreamsAPI(window);\\n      safariShim.shimRemoteStreamsAPI(window);\\n      safariShim.shimGetUserMedia(window);\\n      break;\\n    default:\\n      logging('Unsupported browser!');\\n      break;\\n  }\\n\\n  return adapter;\\n};\\n\\n},{\\\"./chrome/chrome_shim\\\":4,\\\"./edge/edge_shim\\\":6,\\\"./firefox/firefox_shim\\\":9,\\\"./safari/safari_shim\\\":11,\\\"./utils\\\":12}],4:[function(require,module,exports){\\n\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n'use strict';\\nvar utils = require('../utils.js');\\nvar logging = utils.log;\\n\\nvar chromeShim = {\\n  shimMediaStream: function(window) {\\n    window.MediaStream = window.MediaStream || window.webkitMediaStream;\\n  },\\n\\n  shimOnTrack: function(window) {\\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\\n        window.RTCPeerConnection.prototype)) {\\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\\n        get: function() {\\n          return this._ontrack;\\n        },\\n        set: function(f) {\\n          var self = this;\\n          if (this._ontrack) {\\n            this.removeEventListener('track', this._ontrack);\\n            this.removeEventListener('addstream', this._ontrackpoly);\\n          }\\n          this.addEventListener('track', this._ontrack = f);\\n          this.addEventListener('addstream', this._ontrackpoly = function(e) {\\n            // onaddstream does not fire when a track is added to an existing\\n            // stream. But stream.onaddtrack is implemented so we use that.\\n            e.stream.addEventListener('addtrack', function(te) {\\n              var receiver;\\n              if (window.RTCPeerConnection.prototype.getReceivers) {\\n                receiver = self.getReceivers().find(function(r) {\\n                  return r.track.id === te.track.id;\\n                });\\n              } else {\\n                receiver = {track: te.track};\\n              }\\n\\n              var event = new Event('track');\\n              event.track = te.track;\\n              event.receiver = receiver;\\n              event.streams = [e.stream];\\n              self.dispatchEvent(event);\\n            });\\n            e.stream.getTracks().forEach(function(track) {\\n              var receiver;\\n              if (window.RTCPeerConnection.prototype.getReceivers) {\\n                receiver = self.getReceivers().find(function(r) {\\n                  return r.track.id === track.id;\\n                });\\n              } else {\\n                receiver = {track: track};\\n              }\\n              var event = new Event('track');\\n              event.track = track;\\n              event.receiver = receiver;\\n              event.streams = [e.stream];\\n              this.dispatchEvent(event);\\n            }.bind(this));\\n          }.bind(this));\\n        }\\n      });\\n    }\\n  },\\n\\n  shimGetSendersWithDtmf: function(window) {\\n    if (typeof window === 'object' && window.RTCPeerConnection &&\\n        !('getSenders' in window.RTCPeerConnection.prototype) &&\\n        'createDTMFSender' in window.RTCPeerConnection.prototype) {\\n      var shimSenderWithDtmf = function(pc, track) {\\n        return {\\n          track: track,\\n          get dtmf() {\\n            if (this._dtmf === undefined) {\\n              if (track.kind === 'audio') {\\n                this._dtmf = pc.createDTMFSender(track);\\n              } else {\\n                this._dtmf = null;\\n              }\\n            }\\n            return this._dtmf;\\n          }\\n        };\\n      };\\n\\n      // shim addTrack when getSenders is not available.\\n      if (!window.RTCPeerConnection.prototype.getSenders) {\\n        window.RTCPeerConnection.prototype.getSenders = function() {\\n          return this._senders || [];\\n        };\\n        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\\n        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\\n          var pc = this;\\n          var sender = origAddTrack.apply(pc, arguments);\\n          if (!sender) {\\n            sender = shimSenderWithDtmf(pc, track);\\n            pc._senders.push(sender);\\n          }\\n          return sender;\\n        };\\n      }\\n      var origAddStream = window.RTCPeerConnection.prototype.addStream;\\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\\n        var pc = this;\\n        pc._senders = pc._senders || [];\\n        origAddStream.apply(pc, [stream]);\\n        stream.getTracks().forEach(function(track) {\\n          pc._senders.push(shimSenderWithDtmf(pc, track));\\n        });\\n      };\\n\\n      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\\n        var pc = this;\\n        pc._senders = pc._senders || [];\\n        origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);\\n\\n        stream.getTracks().forEach(function(track) {\\n          var sender = pc._senders.find(function(s) {\\n            return s.track === track;\\n          });\\n          if (sender) {\\n            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender\\n          }\\n        });\\n      };\\n    } else if (typeof window === 'object' && window.RTCPeerConnection &&\\n               'getSenders' in window.RTCPeerConnection.prototype &&\\n               'createDTMFSender' in window.RTCPeerConnection.prototype &&\\n               window.RTCRtpSender &&\\n               !('dtmf' in window.RTCRtpSender.prototype)) {\\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\\n      window.RTCPeerConnection.prototype.getSenders = function() {\\n        var pc = this;\\n        var senders = origGetSenders.apply(pc, []);\\n        senders.forEach(function(sender) {\\n          sender._pc = pc;\\n        });\\n        return senders;\\n      };\\n\\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\\n        get: function() {\\n          if (this._dtmf === undefined) {\\n            if (this.track.kind === 'audio') {\\n              this._dtmf = this._pc.createDTMFSender(this.track);\\n            } else {\\n              this._dtmf = null;\\n            }\\n          }\\n          return this._dtmf;\\n        },\\n      });\\n    }\\n  },\\n\\n  shimSourceObject: function(window) {\\n    var URL = window && window.URL;\\n\\n    if (typeof window === 'object') {\\n      if (window.HTMLMediaElement &&\\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\\n          get: function() {\\n            return this._srcObject;\\n          },\\n          set: function(stream) {\\n            var self = this;\\n            // Use _srcObject as a private property for this shim\\n            this._srcObject = stream;\\n            if (this.src) {\\n              URL.revokeObjectURL(this.src);\\n            }\\n\\n            if (!stream) {\\n              this.src = '';\\n              return undefined;\\n            }\\n            this.src = URL.createObjectURL(stream);\\n            // We need to recreate the blob url when a track is added or\\n            // removed. Doing it manually since we want to avoid a recursion.\\n            stream.addEventListener('addtrack', function() {\\n              if (self.src) {\\n                URL.revokeObjectURL(self.src);\\n              }\\n              self.src = URL.createObjectURL(stream);\\n            });\\n            stream.addEventListener('removetrack', function() {\\n              if (self.src) {\\n                URL.revokeObjectURL(self.src);\\n              }\\n              self.src = URL.createObjectURL(stream);\\n            });\\n          }\\n        });\\n      }\\n    }\\n  },\\n\\n  shimAddTrack: function(window) {\\n    // shim addTrack (when getSenders is available)\\n    if (window.RTCPeerConnection.prototype.addTrack) {\\n      return;\\n    }\\n\\n    // also shim pc.getLocalStreams when addTrack is shimmed\\n    // to return the original streams.\\n    var origGetLocalStreams = window.RTCPeerConnection.prototype\\n        .getLocalStreams;\\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\\n      var self = this;\\n      var nativeStreams = origGetLocalStreams.apply(this);\\n      self._reverseStreams = self._reverseStreams || {};\\n      return nativeStreams.map(function(stream) {\\n        return self._reverseStreams[stream.id];\\n      });\\n    };\\n\\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\\n      var pc = this;\\n      pc._streams = pc._streams || {};\\n      pc._reverseStreams = pc._reverseStreams || {};\\n\\n      // Add identity mapping for consistency with addTrack.\\n      // Unless this is being used with a stream from addTrack.\\n      if (!pc._reverseStreams[stream.id]) {\\n        pc._streams[stream.id] = stream;\\n        pc._reverseStreams[stream.id] = stream;\\n      }\\n      origAddStream.apply(pc, [stream]);\\n    };\\n\\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\\n      var pc = this;\\n      pc._streams = pc._streams || {};\\n      pc._reverseStreams = pc._reverseStreams || {};\\n\\n      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);\\n      delete pc._reverseStreams[(pc._streams[stream.id] ?\\n          pc._streams[stream.id].id : stream.id)];\\n      delete pc._streams[stream.id];\\n    };\\n\\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\\n      var pc = this;\\n      if (pc.signalingState === 'closed') {\\n        throw new DOMException(\\n          'The RTCPeerConnection\\\\'s signalingState is \\\\'closed\\\\'.',\\n          'InvalidStateError');\\n      }\\n      var streams = [].slice.call(arguments, 1);\\n      if (streams.length !== 1 ||\\n          !streams[0].getTracks().find(function(t) {\\n            return t === track;\\n          })) {\\n        // this is not fully correct but all we can manage without\\n        // [[associated MediaStreams]] internal slot.\\n        throw new DOMException(\\n          'The adapter.js addTrack polyfill only supports a single ' +\\n          ' stream which is associated with the specified track.',\\n          'NotSupportedError');\\n      }\\n\\n      var alreadyExists = pc.getSenders().find(function(s) {\\n        return s.track === track;\\n      });\\n      if (alreadyExists) {\\n        throw new DOMException('Track already exists.',\\n            'InvalidAccessError');\\n      }\\n\\n      pc._streams = pc._streams || {};\\n      pc._reverseStreams = pc._reverseStreams || {};\\n      var oldStream = pc._streams[stream.id];\\n      if (oldStream) {\\n        // this is using odd Chrome behaviour, use with caution:\\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\\n        oldStream.addTrack(track);\\n        pc.dispatchEvent(new Event('negotiationneeded'));\\n      } else {\\n        var newStream = new window.MediaStream([track]);\\n        pc._streams[stream.id] = newStream;\\n        pc._reverseStreams[newStream.id] = stream;\\n        pc.addStream(newStream);\\n      }\\n      return pc.getSenders().find(function(s) {\\n        return s.track === track;\\n      });\\n    };\\n  },\\n\\n  shimPeerConnection: function(window) {\\n    var browserDetails = utils.detectBrowser(window);\\n\\n    // The RTCPeerConnection object.\\n    if (!window.RTCPeerConnection) {\\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\\n        // Translate iceTransportPolicy to iceTransports,\\n        // see https://code.google.com/p/webrtc/issues/detail?id=4869\\n        // this was fixed in M56 along with unprefixing RTCPeerConnection.\\n        logging('PeerConnection');\\n        if (pcConfig && pcConfig.iceTransportPolicy) {\\n          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\\n        }\\n\\n        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);\\n      };\\n      window.RTCPeerConnection.prototype =\\n          window.webkitRTCPeerConnection.prototype;\\n      // wrap static methods. Currently just generateCertificate.\\n      if (window.webkitRTCPeerConnection.generateCertificate) {\\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\\n          get: function() {\\n            return window.webkitRTCPeerConnection.generateCertificate;\\n          }\\n        });\\n      }\\n    } else {\\n      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\\n      var OrigPeerConnection = window.RTCPeerConnection;\\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\\n        if (pcConfig && pcConfig.iceServers) {\\n          var newIceServers = [];\\n          for (var i = 0; i < pcConfig.iceServers.length; i++) {\\n            var server = pcConfig.iceServers[i];\\n            if (!server.hasOwnProperty('urls') &&\\n                server.hasOwnProperty('url')) {\\n              console.warn('RTCIceServer.url is deprecated! Use urls instead.');\\n              server = JSON.parse(JSON.stringify(server));\\n              server.urls = server.url;\\n              newIceServers.push(server);\\n            } else {\\n              newIceServers.push(pcConfig.iceServers[i]);\\n            }\\n          }\\n          pcConfig.iceServers = newIceServers;\\n        }\\n        return new OrigPeerConnection(pcConfig, pcConstraints);\\n      };\\n      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\\n      // wrap static methods. Currently just generateCertificate.\\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\\n        get: function() {\\n          return OrigPeerConnection.generateCertificate;\\n        }\\n      });\\n    }\\n\\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\\n    window.RTCPeerConnection.prototype.getStats = function(selector,\\n        successCallback, errorCallback) {\\n      var self = this;\\n      var args = arguments;\\n\\n      // If selector is a function then we are in the old style stats so just\\n      // pass back the original getStats format to avoid breaking old users.\\n      if (arguments.length > 0 && typeof selector === 'function') {\\n        return origGetStats.apply(this, arguments);\\n      }\\n\\n      // When spec-style getStats is supported, return those when called with\\n      // either no arguments or the selector argument is null.\\n      if (origGetStats.length === 0 && (arguments.length === 0 ||\\n          typeof arguments[0] !== 'function')) {\\n        return origGetStats.apply(this, []);\\n      }\\n\\n      var fixChromeStats_ = function(response) {\\n        var standardReport = {};\\n        var reports = response.result();\\n        reports.forEach(function(report) {\\n          var standardStats = {\\n            id: report.id,\\n            timestamp: report.timestamp,\\n            type: {\\n              localcandidate: 'local-candidate',\\n              remotecandidate: 'remote-candidate'\\n            }[report.type] || report.type\\n          };\\n          report.names().forEach(function(name) {\\n            standardStats[name] = report.stat(name);\\n          });\\n          standardReport[standardStats.id] = standardStats;\\n        });\\n\\n        return standardReport;\\n      };\\n\\n      // shim getStats with maplike support\\n      var makeMapStats = function(stats) {\\n        return new Map(Object.keys(stats).map(function(key) {\\n          return [key, stats[key]];\\n        }));\\n      };\\n\\n      if (arguments.length >= 2) {\\n        var successCallbackWrapper_ = function(response) {\\n          args[1](makeMapStats(fixChromeStats_(response)));\\n        };\\n\\n        return origGetStats.apply(this, [successCallbackWrapper_,\\n          arguments[0]]);\\n      }\\n\\n      // promise-support\\n      return new Promise(function(resolve, reject) {\\n        origGetStats.apply(self, [\\n          function(response) {\\n            resolve(makeMapStats(fixChromeStats_(response)));\\n          }, reject]);\\n      }).then(successCallback, errorCallback);\\n    };\\n\\n    // add promise support -- natively available in Chrome 51\\n    if (browserDetails.version < 51) {\\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\\n          .forEach(function(method) {\\n            var nativeMethod = window.RTCPeerConnection.prototype[method];\\n            window.RTCPeerConnection.prototype[method] = function() {\\n              var args = arguments;\\n              var self = this;\\n              var promise = new Promise(function(resolve, reject) {\\n                nativeMethod.apply(self, [args[0], resolve, reject]);\\n              });\\n              if (args.length < 2) {\\n                return promise;\\n              }\\n              return promise.then(function() {\\n                args[1].apply(null, []);\\n              },\\n              function(err) {\\n                if (args.length >= 3) {\\n                  args[2].apply(null, [err]);\\n                }\\n              });\\n            };\\n          });\\n    }\\n\\n    // promise support for createOffer and createAnswer. Available (without\\n    // bugs) since M52: crbug/619289\\n    if (browserDetails.version < 52) {\\n      ['createOffer', 'createAnswer'].forEach(function(method) {\\n        var nativeMethod = window.RTCPeerConnection.prototype[method];\\n        window.RTCPeerConnection.prototype[method] = function() {\\n          var self = this;\\n          if (arguments.length < 1 || (arguments.length === 1 &&\\n              typeof arguments[0] === 'object')) {\\n            var opts = arguments.length === 1 ? arguments[0] : undefined;\\n            return new Promise(function(resolve, reject) {\\n              nativeMethod.apply(self, [resolve, reject, opts]);\\n            });\\n          }\\n          return nativeMethod.apply(this, arguments);\\n        };\\n      });\\n    }\\n\\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\\n        .forEach(function(method) {\\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\\n          window.RTCPeerConnection.prototype[method] = function() {\\n            arguments[0] = new ((method === 'addIceCandidate') ?\\n                window.RTCIceCandidate :\\n                window.RTCSessionDescription)(arguments[0]);\\n            return nativeMethod.apply(this, arguments);\\n          };\\n        });\\n\\n    // support for addIceCandidate(null or undefined)\\n    var nativeAddIceCandidate =\\n        window.RTCPeerConnection.prototype.addIceCandidate;\\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\\n      if (!arguments[0]) {\\n        if (arguments[1]) {\\n          arguments[1].apply(null);\\n        }\\n        return Promise.resolve();\\n      }\\n      return nativeAddIceCandidate.apply(this, arguments);\\n    };\\n  }\\n};\\n\\n\\n// Expose public methods.\\nmodule.exports = {\\n  shimMediaStream: chromeShim.shimMediaStream,\\n  shimOnTrack: chromeShim.shimOnTrack,\\n  shimAddTrack: chromeShim.shimAddTrack,\\n  shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf,\\n  shimSourceObject: chromeShim.shimSourceObject,\\n  shimPeerConnection: chromeShim.shimPeerConnection,\\n  shimGetUserMedia: require('./getusermedia')\\n};\\n\\n},{\\\"../utils.js\\\":12,\\\"./getusermedia\\\":5}],5:[function(require,module,exports){\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n'use strict';\\nvar utils = require('../utils.js');\\nvar logging = utils.log;\\n\\n// Expose public methods.\\nmodule.exports = function(window) {\\n  var browserDetails = utils.detectBrowser(window);\\n  var navigator = window && window.navigator;\\n\\n  var constraintsToChrome_ = function(c) {\\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\\n      return c;\\n    }\\n    var cc = {};\\n    Object.keys(c).forEach(function(key) {\\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\\n        return;\\n      }\\n      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\\n      if (r.exact !== undefined && typeof r.exact === 'number') {\\n        r.min = r.max = r.exact;\\n      }\\n      var oldname_ = function(prefix, name) {\\n        if (prefix) {\\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\\n        }\\n        return (name === 'deviceId') ? 'sourceId' : name;\\n      };\\n      if (r.ideal !== undefined) {\\n        cc.optional = cc.optional || [];\\n        var oc = {};\\n        if (typeof r.ideal === 'number') {\\n          oc[oldname_('min', key)] = r.ideal;\\n          cc.optional.push(oc);\\n          oc = {};\\n          oc[oldname_('max', key)] = r.ideal;\\n          cc.optional.push(oc);\\n        } else {\\n          oc[oldname_('', key)] = r.ideal;\\n          cc.optional.push(oc);\\n        }\\n      }\\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\\n        cc.mandatory = cc.mandatory || {};\\n        cc.mandatory[oldname_('', key)] = r.exact;\\n      } else {\\n        ['min', 'max'].forEach(function(mix) {\\n          if (r[mix] !== undefined) {\\n            cc.mandatory = cc.mandatory || {};\\n            cc.mandatory[oldname_(mix, key)] = r[mix];\\n          }\\n        });\\n      }\\n    });\\n    if (c.advanced) {\\n      cc.optional = (cc.optional || []).concat(c.advanced);\\n    }\\n    return cc;\\n  };\\n\\n  var shimConstraints_ = function(constraints, func) {\\n    constraints = JSON.parse(JSON.stringify(constraints));\\n    if (constraints && typeof constraints.audio === 'object') {\\n      var remap = function(obj, a, b) {\\n        if (a in obj && !(b in obj)) {\\n          obj[b] = obj[a];\\n          delete obj[a];\\n        }\\n      };\\n      constraints = JSON.parse(JSON.stringify(constraints));\\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\\n      constraints.audio = constraintsToChrome_(constraints.audio);\\n    }\\n    if (constraints && typeof constraints.video === 'object') {\\n      // Shim facingMode for mobile & surface pro.\\n      var face = constraints.video.facingMode;\\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\\n      var getSupportedFacingModeLies = browserDetails.version < 61;\\n\\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\\n          !(navigator.mediaDevices.getSupportedConstraints &&\\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\\n            !getSupportedFacingModeLies)) {\\n        delete constraints.video.facingMode;\\n        var matches;\\n        if (face.exact === 'environment' || face.ideal === 'environment') {\\n          matches = ['back', 'rear'];\\n        } else if (face.exact === 'user' || face.ideal === 'user') {\\n          matches = ['front'];\\n        }\\n        if (matches) {\\n          // Look for matches in label, or use last cam for back (typical).\\n          return navigator.mediaDevices.enumerateDevices()\\n          .then(function(devices) {\\n            devices = devices.filter(function(d) {\\n              return d.kind === 'videoinput';\\n            });\\n            var dev = devices.find(function(d) {\\n              return matches.some(function(match) {\\n                return d.label.toLowerCase().indexOf(match) !== -1;\\n              });\\n            });\\n            if (!dev && devices.length && matches.indexOf('back') !== -1) {\\n              dev = devices[devices.length - 1]; // more likely the back cam\\n            }\\n            if (dev) {\\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\\n                                                        {ideal: dev.deviceId};\\n            }\\n            constraints.video = constraintsToChrome_(constraints.video);\\n            logging('chrome: ' + JSON.stringify(constraints));\\n            return func(constraints);\\n          });\\n        }\\n      }\\n      constraints.video = constraintsToChrome_(constraints.video);\\n    }\\n    logging('chrome: ' + JSON.stringify(constraints));\\n    return func(constraints);\\n  };\\n\\n  var shimError_ = function(e) {\\n    return {\\n      name: {\\n        PermissionDeniedError: 'NotAllowedError',\\n        InvalidStateError: 'NotReadableError',\\n        DevicesNotFoundError: 'NotFoundError',\\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\\n        TrackStartError: 'NotReadableError',\\n        MediaDeviceFailedDueToShutdown: 'NotReadableError',\\n        MediaDeviceKillSwitchOn: 'NotReadableError'\\n      }[e.name] || e.name,\\n      message: e.message,\\n      constraint: e.constraintName,\\n      toString: function() {\\n        return this.name + (this.message && ': ') + this.message;\\n      }\\n    };\\n  };\\n\\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\\n    shimConstraints_(constraints, function(c) {\\n      navigator.webkitGetUserMedia(c, onSuccess, function(e) {\\n        onError(shimError_(e));\\n      });\\n    });\\n  };\\n\\n  navigator.getUserMedia = getUserMedia_;\\n\\n  // Returns the result of getUserMedia as a Promise.\\n  var getUserMediaPromise_ = function(constraints) {\\n    return new Promise(function(resolve, reject) {\\n      navigator.getUserMedia(constraints, resolve, reject);\\n    });\\n  };\\n\\n  if (!navigator.mediaDevices) {\\n    navigator.mediaDevices = {\\n      getUserMedia: getUserMediaPromise_,\\n      enumerateDevices: function() {\\n        return new Promise(function(resolve) {\\n          var kinds = {audio: 'audioinput', video: 'videoinput'};\\n          return window.MediaStreamTrack.getSources(function(devices) {\\n            resolve(devices.map(function(device) {\\n              return {label: device.label,\\n                kind: kinds[device.kind],\\n                deviceId: device.id,\\n                groupId: ''};\\n            }));\\n          });\\n        });\\n      },\\n      getSupportedConstraints: function() {\\n        return {\\n          deviceId: true, echoCancellation: true, facingMode: true,\\n          frameRate: true, height: true, width: true\\n        };\\n      }\\n    };\\n  }\\n\\n  // A shim for getUserMedia method on the mediaDevices object.\\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\\n  if (!navigator.mediaDevices.getUserMedia) {\\n    navigator.mediaDevices.getUserMedia = function(constraints) {\\n      return getUserMediaPromise_(constraints);\\n    };\\n  } else {\\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\\n    // function which returns a Promise, it does not accept spec-style\\n    // constraints.\\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\\n        bind(navigator.mediaDevices);\\n    navigator.mediaDevices.getUserMedia = function(cs) {\\n      return shimConstraints_(cs, function(c) {\\n        return origGetUserMedia(c).then(function(stream) {\\n          if (c.audio && !stream.getAudioTracks().length ||\\n              c.video && !stream.getVideoTracks().length) {\\n            stream.getTracks().forEach(function(track) {\\n              track.stop();\\n            });\\n            throw new DOMException('', 'NotFoundError');\\n          }\\n          return stream;\\n        }, function(e) {\\n          return Promise.reject(shimError_(e));\\n        });\\n      });\\n    };\\n  }\\n\\n  // Dummy devicechange event methods.\\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\\n  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\\n    navigator.mediaDevices.addEventListener = function() {\\n      logging('Dummy mediaDevices.addEventListener called.');\\n    };\\n  }\\n  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\\n    navigator.mediaDevices.removeEventListener = function() {\\n      logging('Dummy mediaDevices.removeEventListener called.');\\n    };\\n  }\\n};\\n\\n},{\\\"../utils.js\\\":12}],6:[function(require,module,exports){\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n'use strict';\\n\\nvar utils = require('../utils');\\nvar shimRTCPeerConnection = require('./rtcpeerconnection_shim');\\n\\nmodule.exports = {\\n  shimGetUserMedia: require('./getusermedia'),\\n  shimPeerConnection: function(window) {\\n    var browserDetails = utils.detectBrowser(window);\\n\\n    if (window.RTCIceGatherer) {\\n      // ORTC defines an RTCIceCandidate object but no constructor.\\n      // Not implemented in Edge.\\n      if (!window.RTCIceCandidate) {\\n        window.RTCIceCandidate = function(args) {\\n          return args;\\n        };\\n      }\\n      // ORTC does not have a session description object but\\n      // other browsers (i.e. Chrome) that will support both PC and ORTC\\n      // in the future might have this defined already.\\n      if (!window.RTCSessionDescription) {\\n        window.RTCSessionDescription = function(args) {\\n          return args;\\n        };\\n      }\\n      // this adds an additional event listener to MediaStrackTrack that signals\\n      // when a tracks enabled property was changed. Workaround for a bug in\\n      // addStream, see below. No longer required in 15025+\\n      if (browserDetails.version < 15025) {\\n        var origMSTEnabled = Object.getOwnPropertyDescriptor(\\n            window.MediaStreamTrack.prototype, 'enabled');\\n        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\\n          set: function(value) {\\n            origMSTEnabled.set.call(this, value);\\n            var ev = new Event('enabled');\\n            ev.enabled = value;\\n            this.dispatchEvent(ev);\\n          }\\n        });\\n      }\\n    }\\n\\n    // ORTC defines the DTMF sender a bit different.\\n    // https://github.com/w3c/ortc/issues/714\\n    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\\n        get: function() {\\n          if (this._dtmf === undefined) {\\n            if (this.track.kind === 'audio') {\\n              this._dtmf = new window.RTCDtmfSender(this);\\n            } else if (this.track.kind === 'video') {\\n              this._dtmf = null;\\n            }\\n          }\\n          return this._dtmf;\\n        }\\n      });\\n    }\\n\\n    window.RTCPeerConnection =\\n        shimRTCPeerConnection(window, browserDetails.version);\\n  },\\n  shimReplaceTrack: function(window) {\\n    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\\n    if (window.RTCRtpSender &&\\n        !('replaceTrack' in window.RTCRtpSender.prototype)) {\\n      window.RTCRtpSender.prototype.replaceTrack =\\n          window.RTCRtpSender.prototype.setTrack;\\n    }\\n  }\\n};\\n\\n},{\\\"../utils\\\":12,\\\"./getusermedia\\\":7,\\\"./rtcpeerconnection_shim\\\":8}],7:[function(require,module,exports){\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n'use strict';\\n\\n// Expose public methods.\\nmodule.exports = function(window) {\\n  var navigator = window && window.navigator;\\n\\n  var shimError_ = function(e) {\\n    return {\\n      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\\n      message: e.message,\\n      constraint: e.constraint,\\n      toString: function() {\\n        return this.name;\\n      }\\n    };\\n  };\\n\\n  // getUserMedia error shim.\\n  var origGetUserMedia = navigator.mediaDevices.getUserMedia.\\n      bind(navigator.mediaDevices);\\n  navigator.mediaDevices.getUserMedia = function(c) {\\n    return origGetUserMedia(c).catch(function(e) {\\n      return Promise.reject(shimError_(e));\\n    });\\n  };\\n};\\n\\n},{}],8:[function(require,module,exports){\\n/*\\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n'use strict';\\n\\nvar SDPUtils = require('sdp');\\n\\n// sort tracks such that they follow an a-v-a-v...\\n// pattern.\\nfunction sortTracks(tracks) {\\n  var audioTracks = tracks.filter(function(track) {\\n    return track.kind === 'audio';\\n  });\\n  var videoTracks = tracks.filter(function(track) {\\n    return track.kind === 'video';\\n  });\\n  tracks = [];\\n  while (audioTracks.length || videoTracks.length) {\\n    if (audioTracks.length) {\\n      tracks.push(audioTracks.shift());\\n    }\\n    if (videoTracks.length) {\\n      tracks.push(videoTracks.shift());\\n    }\\n  }\\n  return tracks;\\n}\\n\\n// Edge does not like\\n// 1) stun:\\n// 2) turn: that does not have all of turn:host:port?transport=udp\\n// 3) turn: with ipv6 addresses\\n// 4) turn: occurring muliple times\\nfunction filterIceServers(iceServers, edgeVersion) {\\n  var hasTurn = false;\\n  iceServers = JSON.parse(JSON.stringify(iceServers));\\n  return iceServers.filter(function(server) {\\n    if (server && (server.urls || server.url)) {\\n      var urls = server.urls || server.url;\\n      if (server.url && !server.urls) {\\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\\n      }\\n      var isString = typeof urls === 'string';\\n      if (isString) {\\n        urls = [urls];\\n      }\\n      urls = urls.filter(function(url) {\\n        var validTurn = url.indexOf('turn:') === 0 &&\\n            url.indexOf('transport=udp') !== -1 &&\\n            url.indexOf('turn:[') === -1 &&\\n            !hasTurn;\\n\\n        if (validTurn) {\\n          hasTurn = true;\\n          return true;\\n        }\\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393;\\n      });\\n\\n      delete server.url;\\n      server.urls = isString ? urls[0] : urls;\\n      return !!urls.length;\\n    }\\n    return false;\\n  });\\n}\\n\\n// Determines the intersection of local and remote capabilities.\\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\\n  var commonCapabilities = {\\n    codecs: [],\\n    headerExtensions: [],\\n    fecMechanisms: []\\n  };\\n\\n  var findCodecByPayloadType = function(pt, codecs) {\\n    pt = parseInt(pt, 10);\\n    for (var i = 0; i < codecs.length; i++) {\\n      if (codecs[i].payloadType === pt ||\\n          codecs[i].preferredPayloadType === pt) {\\n        return codecs[i];\\n      }\\n    }\\n  };\\n\\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\\n    return lCodec && rCodec &&\\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\\n  };\\n\\n  localCapabilities.codecs.forEach(function(lCodec) {\\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\\n      var rCodec = remoteCapabilities.codecs[i];\\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\\n          lCodec.clockRate === rCodec.clockRate) {\\n        if (lCodec.name.toLowerCase() === 'rtx' &&\\n            lCodec.parameters && rCodec.parameters.apt) {\\n          // for RTX we need to find the local rtx that has a apt\\n          // which points to the same local codec as the remote one.\\n          if (!rtxCapabilityMatches(lCodec, rCodec,\\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\\n            continue;\\n          }\\n        }\\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\\n        // number of channels is the highest common number of channels\\n        rCodec.numChannels = Math.min(lCodec.numChannels,\\n            rCodec.numChannels);\\n        // push rCodec so we reply with offerer payload type\\n        commonCapabilities.codecs.push(rCodec);\\n\\n        // determine common feedback mechanisms\\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\\n              return true;\\n            }\\n          }\\n          return false;\\n        });\\n        // FIXME: also need to determine .parameters\\n        //  see https://github.com/openpeer/ortc/issues/569\\n        break;\\n      }\\n    }\\n  });\\n\\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\\n         i++) {\\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\\n        break;\\n      }\\n    }\\n  });\\n\\n  // FIXME: fecMechanisms\\n  return commonCapabilities;\\n}\\n\\n// is action=setLocalDescription with type allowed in signalingState\\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\\n  return {\\n    offer: {\\n      setLocalDescription: ['stable', 'have-local-offer'],\\n      setRemoteDescription: ['stable', 'have-remote-offer']\\n    },\\n    answer: {\\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\\n    }\\n  }[type][action].indexOf(signalingState) !== -1;\\n}\\n\\nmodule.exports = function(window, edgeVersion) {\\n  var RTCPeerConnection = function(config) {\\n    var self = this;\\n\\n    var _eventTarget = document.createDocumentFragment();\\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\\n        .forEach(function(method) {\\n          self[method] = _eventTarget[method].bind(_eventTarget);\\n        });\\n\\n    this.needNegotiation = false;\\n\\n    this.onicecandidate = null;\\n    this.onaddstream = null;\\n    this.ontrack = null;\\n    this.onremovestream = null;\\n    this.onsignalingstatechange = null;\\n    this.oniceconnectionstatechange = null;\\n    this.onicegatheringstatechange = null;\\n    this.onnegotiationneeded = null;\\n    this.ondatachannel = null;\\n    this.canTrickleIceCandidates = null;\\n\\n    this.localStreams = [];\\n    this.remoteStreams = [];\\n    this.getLocalStreams = function() {\\n      return self.localStreams;\\n    };\\n    this.getRemoteStreams = function() {\\n      return self.remoteStreams;\\n    };\\n\\n    this.localDescription = new window.RTCSessionDescription({\\n      type: '',\\n      sdp: ''\\n    });\\n    this.remoteDescription = new window.RTCSessionDescription({\\n      type: '',\\n      sdp: ''\\n    });\\n    this.signalingState = 'stable';\\n    this.iceConnectionState = 'new';\\n    this.iceGatheringState = 'new';\\n\\n    this.iceOptions = {\\n      gatherPolicy: 'all',\\n      iceServers: []\\n    };\\n    if (config && config.iceTransportPolicy) {\\n      switch (config.iceTransportPolicy) {\\n        case 'all':\\n        case 'relay':\\n          this.iceOptions.gatherPolicy = config.iceTransportPolicy;\\n          break;\\n        default:\\n          // don't set iceTransportPolicy.\\n          break;\\n      }\\n    }\\n    this.usingBundle = config && config.bundlePolicy === 'max-bundle';\\n\\n    if (config && config.iceServers) {\\n      this.iceOptions.iceServers = filterIceServers(config.iceServers,\\n          edgeVersion);\\n    }\\n    this._config = config || {};\\n\\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\\n    // everything that is needed to describe a SDP m-line.\\n    this.transceivers = [];\\n\\n    // since the iceGatherer is currently created in createOffer but we\\n    // must not emit candidates until after setLocalDescription we buffer\\n    // them in this array.\\n    this._localIceCandidatesBuffer = [];\\n\\n    this._sdpSessionId = SDPUtils.generateSessionId();\\n  };\\n\\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\\n    var event = new Event('icegatheringstatechange');\\n    this.dispatchEvent(event);\\n    if (this.onicegatheringstatechange !== null) {\\n      this.onicegatheringstatechange(event);\\n    }\\n  };\\n\\n  RTCPeerConnection.prototype._emitBufferedCandidates = function() {\\n    var self = this;\\n    var sections = SDPUtils.splitSections(self.localDescription.sdp);\\n    // FIXME: need to apply ice candidates in a way which is async but\\n    // in-order\\n    this._localIceCandidatesBuffer.forEach(function(event) {\\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\\n      if (end) {\\n        for (var j = 1; j < sections.length; j++) {\\n          if (sections[j].indexOf('\\\\r\\\\na=end-of-candidates\\\\r\\\\n') === -1) {\\n            sections[j] += 'a=end-of-candidates\\\\r\\\\n';\\n          }\\n        }\\n      } else {\\n        sections[event.candidate.sdpMLineIndex + 1] +=\\n            'a=' + event.candidate.candidate + '\\\\r\\\\n';\\n      }\\n      self.localDescription.sdp = sections.join('');\\n      self.dispatchEvent(event);\\n      if (self.onicecandidate !== null) {\\n        self.onicecandidate(event);\\n      }\\n      if (!event.candidate && self.iceGatheringState !== 'complete') {\\n        var complete = self.transceivers.every(function(transceiver) {\\n          return transceiver.iceGatherer &&\\n              transceiver.iceGatherer.state === 'completed';\\n        });\\n        if (complete && self.iceGatheringStateChange !== 'complete') {\\n          self.iceGatheringState = 'complete';\\n          self._emitGatheringStateChange();\\n        }\\n      }\\n    });\\n    this._localIceCandidatesBuffer = [];\\n  };\\n\\n  RTCPeerConnection.prototype.getConfiguration = function() {\\n    return this._config;\\n  };\\n\\n  // internal helper to create a transceiver object.\\n  // (whih is not yet the same as the WebRTC 1.0 transceiver)\\n  RTCPeerConnection.prototype._createTransceiver = function(kind) {\\n    var hasBundleTransport = this.transceivers.length > 0;\\n    var transceiver = {\\n      track: null,\\n      iceGatherer: null,\\n      iceTransport: null,\\n      dtlsTransport: null,\\n      localCapabilities: null,\\n      remoteCapabilities: null,\\n      rtpSender: null,\\n      rtpReceiver: null,\\n      kind: kind,\\n      mid: null,\\n      sendEncodingParameters: null,\\n      recvEncodingParameters: null,\\n      stream: null,\\n      wantReceive: true\\n    };\\n    if (this.usingBundle && hasBundleTransport) {\\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\\n    } else {\\n      var transports = this._createIceAndDtlsTransports();\\n      transceiver.iceTransport = transports.iceTransport;\\n      transceiver.dtlsTransport = transports.dtlsTransport;\\n    }\\n    this.transceivers.push(transceiver);\\n    return transceiver;\\n  };\\n\\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\\n    var transceiver;\\n    for (var i = 0; i < this.transceivers.length; i++) {\\n      if (!this.transceivers[i].track &&\\n          this.transceivers[i].kind === track.kind) {\\n        transceiver = this.transceivers[i];\\n      }\\n    }\\n    if (!transceiver) {\\n      transceiver = this._createTransceiver(track.kind);\\n    }\\n\\n    transceiver.track = track;\\n    transceiver.stream = stream;\\n    transceiver.rtpSender = new window.RTCRtpSender(track,\\n        transceiver.dtlsTransport);\\n\\n    this._maybeFireNegotiationNeeded();\\n    return transceiver.rtpSender;\\n  };\\n\\n  RTCPeerConnection.prototype.addStream = function(stream) {\\n    var self = this;\\n    if (edgeVersion >= 15025) {\\n      this.localStreams.push(stream);\\n      stream.getTracks().forEach(function(track) {\\n        self.addTrack(track, stream);\\n      });\\n    } else {\\n      // Clone is necessary for local demos mostly, attaching directly\\n      // to two different senders does not work (build 10547).\\n      // Fixed in 15025 (or earlier)\\n      var clonedStream = stream.clone();\\n      stream.getTracks().forEach(function(track, idx) {\\n        var clonedTrack = clonedStream.getTracks()[idx];\\n        track.addEventListener('enabled', function(event) {\\n          clonedTrack.enabled = event.enabled;\\n        });\\n      });\\n      clonedStream.getTracks().forEach(function(track) {\\n        self.addTrack(track, clonedStream);\\n      });\\n      this.localStreams.push(clonedStream);\\n    }\\n    this._maybeFireNegotiationNeeded();\\n  };\\n\\n  RTCPeerConnection.prototype.removeStream = function(stream) {\\n    var idx = this.localStreams.indexOf(stream);\\n    if (idx > -1) {\\n      this.localStreams.splice(idx, 1);\\n      this._maybeFireNegotiationNeeded();\\n    }\\n  };\\n\\n  RTCPeerConnection.prototype.getSenders = function() {\\n    return this.transceivers.filter(function(transceiver) {\\n      return !!transceiver.rtpSender;\\n    })\\n    .map(function(transceiver) {\\n      return transceiver.rtpSender;\\n    });\\n  };\\n\\n  RTCPeerConnection.prototype.getReceivers = function() {\\n    return this.transceivers.filter(function(transceiver) {\\n      return !!transceiver.rtpReceiver;\\n    })\\n    .map(function(transceiver) {\\n      return transceiver.rtpReceiver;\\n    });\\n  };\\n\\n  // Create ICE gatherer and hook it up.\\n  RTCPeerConnection.prototype._createIceGatherer = function(mid,\\n      sdpMLineIndex) {\\n    var self = this;\\n    var iceGatherer = new window.RTCIceGatherer(self.iceOptions);\\n    iceGatherer.onlocalcandidate = function(evt) {\\n      var event = new Event('icecandidate');\\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\\n\\n      var cand = evt.candidate;\\n      var end = !cand || Object.keys(cand).length === 0;\\n      // Edge emits an empty object for RTCIceCandidateComplete‥\\n      if (end) {\\n        // polyfill since RTCIceGatherer.state is not implemented in\\n        // Edge 10547 yet.\\n        if (iceGatherer.state === undefined) {\\n          iceGatherer.state = 'completed';\\n        }\\n      } else {\\n        // RTCIceCandidate doesn't have a component, needs to be added\\n        cand.component = 1;\\n        event.candidate.candidate = SDPUtils.writeCandidate(cand);\\n      }\\n\\n      // update local description.\\n      var sections = SDPUtils.splitSections(self.localDescription.sdp);\\n      if (!end) {\\n        sections[event.candidate.sdpMLineIndex + 1] +=\\n            'a=' + event.candidate.candidate + '\\\\r\\\\n';\\n      } else {\\n        sections[event.candidate.sdpMLineIndex + 1] +=\\n            'a=end-of-candidates\\\\r\\\\n';\\n      }\\n      self.localDescription.sdp = sections.join('');\\n      var transceivers = self._pendingOffer ? self._pendingOffer :\\n          self.transceivers;\\n      var complete = transceivers.every(function(transceiver) {\\n        return transceiver.iceGatherer &&\\n            transceiver.iceGatherer.state === 'completed';\\n      });\\n\\n      // Emit candidate if localDescription is set.\\n      // Also emits null candidate when all gatherers are complete.\\n      switch (self.iceGatheringState) {\\n        case 'new':\\n          if (!end) {\\n            self._localIceCandidatesBuffer.push(event);\\n          }\\n          if (end && complete) {\\n            self._localIceCandidatesBuffer.push(\\n                new Event('icecandidate'));\\n          }\\n          break;\\n        case 'gathering':\\n          self._emitBufferedCandidates();\\n          if (!end) {\\n            self.dispatchEvent(event);\\n            if (self.onicecandidate !== null) {\\n              self.onicecandidate(event);\\n            }\\n          }\\n          if (complete) {\\n            self.dispatchEvent(new Event('icecandidate'));\\n            if (self.onicecandidate !== null) {\\n              self.onicecandidate(new Event('icecandidate'));\\n            }\\n            self.iceGatheringState = 'complete';\\n            self._emitGatheringStateChange();\\n          }\\n          break;\\n        case 'complete':\\n          // should not happen... currently!\\n          break;\\n        default: // no-op.\\n          break;\\n      }\\n    };\\n    return iceGatherer;\\n  };\\n\\n  // Create ICE transport and DTLS transport.\\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\\n    var self = this;\\n    var iceTransport = new window.RTCIceTransport(null);\\n    iceTransport.onicestatechange = function() {\\n      self._updateConnectionState();\\n    };\\n\\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\\n    dtlsTransport.ondtlsstatechange = function() {\\n      self._updateConnectionState();\\n    };\\n    dtlsTransport.onerror = function() {\\n      // onerror does not set state to failed by itself.\\n      Object.defineProperty(dtlsTransport, 'state',\\n          {value: 'failed', writable: true});\\n      self._updateConnectionState();\\n    };\\n\\n    return {\\n      iceTransport: iceTransport,\\n      dtlsTransport: dtlsTransport\\n    };\\n  };\\n\\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\\n  // Without triggering the callbacks.\\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\\n      sdpMLineIndex) {\\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\\n    if (iceGatherer) {\\n      delete iceGatherer.onlocalcandidate;\\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\\n    }\\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\\n    if (iceTransport) {\\n      delete iceTransport.onicestatechange;\\n      delete this.transceivers[sdpMLineIndex].iceTransport;\\n    }\\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\\n    if (dtlsTransport) {\\n      delete dtlsTransport.ondtlsstatechange;\\n      delete dtlsTransport.onerror;\\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\\n    }\\n  };\\n\\n  // Start the RTP Sender and Receiver for a transceiver.\\n  RTCPeerConnection.prototype._transceive = function(transceiver,\\n      send, recv) {\\n    var params = getCommonCapabilities(transceiver.localCapabilities,\\n        transceiver.remoteCapabilities);\\n    if (send && transceiver.rtpSender) {\\n      params.encodings = transceiver.sendEncodingParameters;\\n      params.rtcp = {\\n        cname: SDPUtils.localCName,\\n        compound: transceiver.rtcpParameters.compound\\n      };\\n      if (transceiver.recvEncodingParameters.length) {\\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\\n      }\\n      transceiver.rtpSender.send(params);\\n    }\\n    if (recv && transceiver.rtpReceiver) {\\n      // remove RTX field in Edge 14942\\n      if (transceiver.kind === 'video'\\n          && transceiver.recvEncodingParameters\\n          && edgeVersion < 15019) {\\n        transceiver.recvEncodingParameters.forEach(function(p) {\\n          delete p.rtx;\\n        });\\n      }\\n      params.encodings = transceiver.recvEncodingParameters;\\n      params.rtcp = {\\n        cname: transceiver.rtcpParameters.cname,\\n        compound: transceiver.rtcpParameters.compound\\n      };\\n      if (transceiver.sendEncodingParameters.length) {\\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\\n      }\\n      transceiver.rtpReceiver.receive(params);\\n    }\\n  };\\n\\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\\n    var self = this;\\n\\n    if (!isActionAllowedInSignalingState('setLocalDescription',\\n        description.type, this.signalingState)) {\\n      var e = new Error('Can not set local ' + description.type +\\n          ' in state ' + this.signalingState);\\n      e.name = 'InvalidStateError';\\n      if (arguments.length > 2 && typeof arguments[2] === 'function') {\\n        window.setTimeout(arguments[2], 0, e);\\n      }\\n      return Promise.reject(e);\\n    }\\n\\n    var sections;\\n    var sessionpart;\\n    if (description.type === 'offer') {\\n      // FIXME: What was the purpose of this empty if statement?\\n      // if (!this._pendingOffer) {\\n      // } else {\\n      if (this._pendingOffer) {\\n        // VERY limited support for SDP munging. Limited to:\\n        // * changing the order of codecs\\n        sections = SDPUtils.splitSections(description.sdp);\\n        sessionpart = sections.shift();\\n        sections.forEach(function(mediaSection, sdpMLineIndex) {\\n          var caps = SDPUtils.parseRtpParameters(mediaSection);\\n          self._pendingOffer[sdpMLineIndex].localCapabilities = caps;\\n        });\\n        this.transceivers = this._pendingOffer;\\n        delete this._pendingOffer;\\n      }\\n    } else if (description.type === 'answer') {\\n      sections = SDPUtils.splitSections(self.remoteDescription.sdp);\\n      sessionpart = sections.shift();\\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\\n          'a=ice-lite').length > 0;\\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\\n        var transceiver = self.transceivers[sdpMLineIndex];\\n        var iceGatherer = transceiver.iceGatherer;\\n        var iceTransport = transceiver.iceTransport;\\n        var dtlsTransport = transceiver.dtlsTransport;\\n        var localCapabilities = transceiver.localCapabilities;\\n        var remoteCapabilities = transceiver.remoteCapabilities;\\n\\n        var rejected = SDPUtils.isRejected(mediaSection);\\n\\n        if (!rejected && !transceiver.isDatachannel) {\\n          var remoteIceParameters = SDPUtils.getIceParameters(\\n              mediaSection, sessionpart);\\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\\n              mediaSection, sessionpart);\\n          if (isIceLite) {\\n            remoteDtlsParameters.role = 'server';\\n          }\\n\\n          if (!self.usingBundle || sdpMLineIndex === 0) {\\n            iceTransport.start(iceGatherer, remoteIceParameters,\\n                isIceLite ? 'controlling' : 'controlled');\\n            dtlsTransport.start(remoteDtlsParameters);\\n          }\\n\\n          // Calculate intersection of capabilities.\\n          var params = getCommonCapabilities(localCapabilities,\\n              remoteCapabilities);\\n\\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\\n          // transceiver has already been started in setRemoteDescription.\\n          self._transceive(transceiver,\\n              params.codecs.length > 0,\\n              false);\\n        }\\n      });\\n    }\\n\\n    this.localDescription = {\\n      type: description.type,\\n      sdp: description.sdp\\n    };\\n    switch (description.type) {\\n      case 'offer':\\n        this._updateSignalingState('have-local-offer');\\n        break;\\n      case 'answer':\\n        this._updateSignalingState('stable');\\n        break;\\n      default:\\n        throw new TypeError('unsupported type \\\"' + description.type +\\n            '\\\"');\\n    }\\n\\n    // If a success callback was provided, emit ICE candidates after it\\n    // has been executed. Otherwise, emit callback after the Promise is\\n    // resolved.\\n    var hasCallback = arguments.length > 1 &&\\n      typeof arguments[1] === 'function';\\n    if (hasCallback) {\\n      var cb = arguments[1];\\n      window.setTimeout(function() {\\n        cb();\\n        if (self.iceGatheringState === 'new') {\\n          self.iceGatheringState = 'gathering';\\n          self._emitGatheringStateChange();\\n        }\\n        self._emitBufferedCandidates();\\n      }, 0);\\n    }\\n    var p = Promise.resolve();\\n    p.then(function() {\\n      if (!hasCallback) {\\n        if (self.iceGatheringState === 'new') {\\n          self.iceGatheringState = 'gathering';\\n          self._emitGatheringStateChange();\\n        }\\n        // Usually candidates will be emitted earlier.\\n        window.setTimeout(self._emitBufferedCandidates.bind(self), 500);\\n      }\\n    });\\n    return p;\\n  };\\n\\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\\n    var self = this;\\n\\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\\n        description.type, this.signalingState)) {\\n      var e = new Error('Can not set remote ' + description.type +\\n          ' in state ' + this.signalingState);\\n      e.name = 'InvalidStateError';\\n      if (arguments.length > 2 && typeof arguments[2] === 'function') {\\n        window.setTimeout(arguments[2], 0, e);\\n      }\\n      return Promise.reject(e);\\n    }\\n\\n    var streams = {};\\n    var receiverList = [];\\n    var sections = SDPUtils.splitSections(description.sdp);\\n    var sessionpart = sections.shift();\\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\\n        'a=ice-lite').length > 0;\\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\\n        'a=group:BUNDLE ').length > 0;\\n    this.usingBundle = usingBundle;\\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\\n        'a=ice-options:')[0];\\n    if (iceOptions) {\\n      this.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\\n          .indexOf('trickle') >= 0;\\n    } else {\\n      this.canTrickleIceCandidates = false;\\n    }\\n\\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\\n      var lines = SDPUtils.splitLines(mediaSection);\\n      var kind = SDPUtils.getKind(mediaSection);\\n      var rejected = SDPUtils.isRejected(mediaSection);\\n      var protocol = lines[0].substr(2).split(' ')[2];\\n\\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\\n\\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\\n\\n      // Reject datachannels which are not implemented yet.\\n      if (kind === 'application' && protocol === 'DTLS/SCTP') {\\n        self.transceivers[sdpMLineIndex] = {\\n          mid: mid,\\n          isDatachannel: true\\n        };\\n        return;\\n      }\\n\\n      var transceiver;\\n      var iceGatherer;\\n      var iceTransport;\\n      var dtlsTransport;\\n      var rtpReceiver;\\n      var sendEncodingParameters;\\n      var recvEncodingParameters;\\n      var localCapabilities;\\n\\n      var track;\\n      // FIXME: ensure the mediaSection has rtcp-mux set.\\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\\n      var remoteIceParameters;\\n      var remoteDtlsParameters;\\n      if (!rejected) {\\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\\n            sessionpart);\\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\\n            sessionpart);\\n        remoteDtlsParameters.role = 'client';\\n      }\\n      recvEncodingParameters =\\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\\n\\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\\n\\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\\n          'a=end-of-candidates', sessionpart).length > 0;\\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\\n          .map(function(cand) {\\n            return SDPUtils.parseCandidate(cand);\\n          })\\n          .filter(function(cand) {\\n            return cand.component === '1' || cand.component === 1;\\n          });\\n\\n      // Check if we can use BUNDLE and dispose transports.\\n      if ((description.type === 'offer' || description.type === 'answer') &&\\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\\n          self.transceivers[sdpMLineIndex]) {\\n        self._disposeIceAndDtlsTransports(sdpMLineIndex);\\n        self.transceivers[sdpMLineIndex].iceGatherer =\\n            self.transceivers[0].iceGatherer;\\n        self.transceivers[sdpMLineIndex].iceTransport =\\n            self.transceivers[0].iceTransport;\\n        self.transceivers[sdpMLineIndex].dtlsTransport =\\n            self.transceivers[0].dtlsTransport;\\n        if (self.transceivers[sdpMLineIndex].rtpSender) {\\n          self.transceivers[sdpMLineIndex].rtpSender.setTransport(\\n              self.transceivers[0].dtlsTransport);\\n        }\\n        if (self.transceivers[sdpMLineIndex].rtpReceiver) {\\n          self.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\\n              self.transceivers[0].dtlsTransport);\\n        }\\n      }\\n      if (description.type === 'offer' && !rejected) {\\n        transceiver = self.transceivers[sdpMLineIndex] ||\\n            self._createTransceiver(kind);\\n        transceiver.mid = mid;\\n\\n        if (!transceiver.iceGatherer) {\\n          transceiver.iceGatherer = usingBundle && sdpMLineIndex > 0 ?\\n              self.transceivers[0].iceGatherer :\\n              self._createIceGatherer(mid, sdpMLineIndex);\\n        }\\n\\n        if (isComplete && cands.length &&\\n            (!usingBundle || sdpMLineIndex === 0)) {\\n          transceiver.iceTransport.setRemoteCandidates(cands);\\n        }\\n\\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\\n\\n        // filter RTX until additional stuff needed for RTX is implemented\\n        // in adapter.js\\n        if (edgeVersion < 15019) {\\n          localCapabilities.codecs = localCapabilities.codecs.filter(\\n              function(codec) {\\n                return codec.name !== 'rtx';\\n              });\\n        }\\n\\n        sendEncodingParameters = [{\\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\\n        }];\\n\\n        if (direction === 'sendrecv' || direction === 'sendonly') {\\n          rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport,\\n              kind);\\n\\n          track = rtpReceiver.track;\\n          // FIXME: does not work with Plan B.\\n          if (remoteMsid) {\\n            if (!streams[remoteMsid.stream]) {\\n              streams[remoteMsid.stream] = new window.MediaStream();\\n              Object.defineProperty(streams[remoteMsid.stream], 'id', {\\n                get: function() {\\n                  return remoteMsid.stream;\\n                }\\n              });\\n            }\\n            Object.defineProperty(track, 'id', {\\n              get: function() {\\n                return remoteMsid.track;\\n              }\\n            });\\n            streams[remoteMsid.stream].addTrack(track);\\n            receiverList.push([track, rtpReceiver,\\n              streams[remoteMsid.stream]]);\\n          } else {\\n            if (!streams.default) {\\n              streams.default = new window.MediaStream();\\n            }\\n            streams.default.addTrack(track);\\n            receiverList.push([track, rtpReceiver, streams.default]);\\n          }\\n        }\\n\\n        transceiver.localCapabilities = localCapabilities;\\n        transceiver.remoteCapabilities = remoteCapabilities;\\n        transceiver.rtpReceiver = rtpReceiver;\\n        transceiver.rtcpParameters = rtcpParameters;\\n        transceiver.sendEncodingParameters = sendEncodingParameters;\\n        transceiver.recvEncodingParameters = recvEncodingParameters;\\n\\n        // Start the RTCRtpReceiver now. The RTPSender is started in\\n        // setLocalDescription.\\n        self._transceive(self.transceivers[sdpMLineIndex],\\n            false,\\n            direction === 'sendrecv' || direction === 'sendonly');\\n      } else if (description.type === 'answer' && !rejected) {\\n        transceiver = self.transceivers[sdpMLineIndex];\\n        iceGatherer = transceiver.iceGatherer;\\n        iceTransport = transceiver.iceTransport;\\n        dtlsTransport = transceiver.dtlsTransport;\\n        rtpReceiver = transceiver.rtpReceiver;\\n        sendEncodingParameters = transceiver.sendEncodingParameters;\\n        localCapabilities = transceiver.localCapabilities;\\n\\n        self.transceivers[sdpMLineIndex].recvEncodingParameters =\\n            recvEncodingParameters;\\n        self.transceivers[sdpMLineIndex].remoteCapabilities =\\n            remoteCapabilities;\\n        self.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\\n\\n        if (!usingBundle || sdpMLineIndex === 0) {\\n          if ((isIceLite || isComplete) && cands.length) {\\n            iceTransport.setRemoteCandidates(cands);\\n          }\\n          iceTransport.start(iceGatherer, remoteIceParameters,\\n              'controlling');\\n          dtlsTransport.start(remoteDtlsParameters);\\n        }\\n\\n        self._transceive(transceiver,\\n            direction === 'sendrecv' || direction === 'recvonly',\\n            direction === 'sendrecv' || direction === 'sendonly');\\n\\n        if (rtpReceiver &&\\n            (direction === 'sendrecv' || direction === 'sendonly')) {\\n          track = rtpReceiver.track;\\n          if (remoteMsid) {\\n            if (!streams[remoteMsid.stream]) {\\n              streams[remoteMsid.stream] = new window.MediaStream();\\n            }\\n            streams[remoteMsid.stream].addTrack(track);\\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\\n          } else {\\n            if (!streams.default) {\\n              streams.default = new window.MediaStream();\\n            }\\n            streams.default.addTrack(track);\\n            receiverList.push([track, rtpReceiver, streams.default]);\\n          }\\n        } else {\\n          // FIXME: actually the receiver should be created later.\\n          delete transceiver.rtpReceiver;\\n        }\\n      }\\n    });\\n\\n    this.remoteDescription = {\\n      type: description.type,\\n      sdp: description.sdp\\n    };\\n    switch (description.type) {\\n      case 'offer':\\n        this._updateSignalingState('have-remote-offer');\\n        break;\\n      case 'answer':\\n        this._updateSignalingState('stable');\\n        break;\\n      default:\\n        throw new TypeError('unsupported type \\\"' + description.type +\\n            '\\\"');\\n    }\\n    Object.keys(streams).forEach(function(sid) {\\n      var stream = streams[sid];\\n      if (stream.getTracks().length) {\\n        self.remoteStreams.push(stream);\\n        var event = new Event('addstream');\\n        event.stream = stream;\\n        self.dispatchEvent(event);\\n        if (self.onaddstream !== null) {\\n          window.setTimeout(function() {\\n            self.onaddstream(event);\\n          }, 0);\\n        }\\n\\n        receiverList.forEach(function(item) {\\n          var track = item[0];\\n          var receiver = item[1];\\n          if (stream.id !== item[2].id) {\\n            return;\\n          }\\n          var trackEvent = new Event('track');\\n          trackEvent.track = track;\\n          trackEvent.receiver = receiver;\\n          trackEvent.streams = [stream];\\n          self.dispatchEvent(trackEvent);\\n          if (self.ontrack !== null) {\\n            window.setTimeout(function() {\\n              self.ontrack(trackEvent);\\n            }, 0);\\n          }\\n        });\\n      }\\n    });\\n\\n    // check whether addIceCandidate({}) was called within four seconds after\\n    // setRemoteDescription.\\n    window.setTimeout(function() {\\n      if (!(self && self.transceivers)) {\\n        return;\\n      }\\n      self.transceivers.forEach(function(transceiver) {\\n        if (transceiver.iceTransport &&\\n            transceiver.iceTransport.state === 'new' &&\\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\\n              'an end-of-candidates notification');\\n          transceiver.iceTransport.addRemoteCandidate({});\\n        }\\n      });\\n    }, 4000);\\n\\n    if (arguments.length > 1 && typeof arguments[1] === 'function') {\\n      window.setTimeout(arguments[1], 0);\\n    }\\n    return Promise.resolve();\\n  };\\n\\n  RTCPeerConnection.prototype.close = function() {\\n    this.transceivers.forEach(function(transceiver) {\\n      /* not yet\\n      if (transceiver.iceGatherer) {\\n        transceiver.iceGatherer.close();\\n      }\\n      */\\n      if (transceiver.iceTransport) {\\n        transceiver.iceTransport.stop();\\n      }\\n      if (transceiver.dtlsTransport) {\\n        transceiver.dtlsTransport.stop();\\n      }\\n      if (transceiver.rtpSender) {\\n        transceiver.rtpSender.stop();\\n      }\\n      if (transceiver.rtpReceiver) {\\n        transceiver.rtpReceiver.stop();\\n      }\\n    });\\n    // FIXME: clean up tracks, local streams, remote streams, etc\\n    this._updateSignalingState('closed');\\n  };\\n\\n  // Update the signaling state.\\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\\n    this.signalingState = newState;\\n    var event = new Event('signalingstatechange');\\n    this.dispatchEvent(event);\\n    if (this.onsignalingstatechange !== null) {\\n      this.onsignalingstatechange(event);\\n    }\\n  };\\n\\n  // Determine whether to fire the negotiationneeded event.\\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\\n    var self = this;\\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\\n      return;\\n    }\\n    this.needNegotiation = true;\\n    window.setTimeout(function() {\\n      if (self.needNegotiation === false) {\\n        return;\\n      }\\n      self.needNegotiation = false;\\n      var event = new Event('negotiationneeded');\\n      self.dispatchEvent(event);\\n      if (self.onnegotiationneeded !== null) {\\n        self.onnegotiationneeded(event);\\n      }\\n    }, 0);\\n  };\\n\\n  // Update the connection state.\\n  RTCPeerConnection.prototype._updateConnectionState = function() {\\n    var self = this;\\n    var newState;\\n    var states = {\\n      'new': 0,\\n      closed: 0,\\n      connecting: 0,\\n      checking: 0,\\n      connected: 0,\\n      completed: 0,\\n      disconnected: 0,\\n      failed: 0\\n    };\\n    this.transceivers.forEach(function(transceiver) {\\n      states[transceiver.iceTransport.state]++;\\n      states[transceiver.dtlsTransport.state]++;\\n    });\\n    // ICETransport.completed and connected are the same for this purpose.\\n    states.connected += states.completed;\\n\\n    newState = 'new';\\n    if (states.failed > 0) {\\n      newState = 'failed';\\n    } else if (states.connecting > 0 || states.checking > 0) {\\n      newState = 'connecting';\\n    } else if (states.disconnected > 0) {\\n      newState = 'disconnected';\\n    } else if (states.new > 0) {\\n      newState = 'new';\\n    } else if (states.connected > 0 || states.completed > 0) {\\n      newState = 'connected';\\n    }\\n\\n    if (newState !== self.iceConnectionState) {\\n      self.iceConnectionState = newState;\\n      var event = new Event('iceconnectionstatechange');\\n      this.dispatchEvent(event);\\n      if (this.oniceconnectionstatechange !== null) {\\n        this.oniceconnectionstatechange(event);\\n      }\\n    }\\n  };\\n\\n  RTCPeerConnection.prototype.createOffer = function() {\\n    var self = this;\\n    if (this._pendingOffer) {\\n      throw new Error('createOffer called while there is a pending offer.');\\n    }\\n    var offerOptions;\\n    if (arguments.length === 1 && typeof arguments[0] !== 'function') {\\n      offerOptions = arguments[0];\\n    } else if (arguments.length === 3) {\\n      offerOptions = arguments[2];\\n    }\\n\\n    var numAudioTracks = this.transceivers.filter(function(t) {\\n      return t.kind === 'audio';\\n    }).length;\\n    var numVideoTracks = this.transceivers.filter(function(t) {\\n      return t.kind === 'video';\\n    }).length;\\n\\n    // Determine number of audio and video tracks we need to send/recv.\\n    if (offerOptions) {\\n      // Reject Chrome legacy constraints.\\n      if (offerOptions.mandatory || offerOptions.optional) {\\n        throw new TypeError(\\n            'Legacy mandatory/optional constraints not supported.');\\n      }\\n      if (offerOptions.offerToReceiveAudio !== undefined) {\\n        if (offerOptions.offerToReceiveAudio === true) {\\n          numAudioTracks = 1;\\n        } else if (offerOptions.offerToReceiveAudio === false) {\\n          numAudioTracks = 0;\\n        } else {\\n          numAudioTracks = offerOptions.offerToReceiveAudio;\\n        }\\n      }\\n      if (offerOptions.offerToReceiveVideo !== undefined) {\\n        if (offerOptions.offerToReceiveVideo === true) {\\n          numVideoTracks = 1;\\n        } else if (offerOptions.offerToReceiveVideo === false) {\\n          numVideoTracks = 0;\\n        } else {\\n          numVideoTracks = offerOptions.offerToReceiveVideo;\\n        }\\n      }\\n    }\\n\\n    this.transceivers.forEach(function(transceiver) {\\n      if (transceiver.kind === 'audio') {\\n        numAudioTracks--;\\n        if (numAudioTracks < 0) {\\n          transceiver.wantReceive = false;\\n        }\\n      } else if (transceiver.kind === 'video') {\\n        numVideoTracks--;\\n        if (numVideoTracks < 0) {\\n          transceiver.wantReceive = false;\\n        }\\n      }\\n    });\\n\\n    // Create M-lines for recvonly streams.\\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\\n      if (numAudioTracks > 0) {\\n        this._createTransceiver('audio');\\n        numAudioTracks--;\\n      }\\n      if (numVideoTracks > 0) {\\n        this._createTransceiver('video');\\n        numVideoTracks--;\\n      }\\n    }\\n    // reorder tracks\\n    var transceivers = sortTracks(this.transceivers);\\n\\n    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId);\\n    transceivers.forEach(function(transceiver, sdpMLineIndex) {\\n      // For each track, create an ice gatherer, ice transport,\\n      // dtls transport, potentially rtpsender and rtpreceiver.\\n      var track = transceiver.track;\\n      var kind = transceiver.kind;\\n      var mid = SDPUtils.generateIdentifier();\\n      transceiver.mid = mid;\\n\\n      if (!transceiver.iceGatherer) {\\n        transceiver.iceGatherer = self.usingBundle && sdpMLineIndex > 0 ?\\n            transceivers[0].iceGatherer :\\n            self._createIceGatherer(mid, sdpMLineIndex);\\n      }\\n\\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\\n      // filter RTX until additional stuff needed for RTX is implemented\\n      // in adapter.js\\n      if (edgeVersion < 15019) {\\n        localCapabilities.codecs = localCapabilities.codecs.filter(\\n            function(codec) {\\n              return codec.name !== 'rtx';\\n            });\\n      }\\n      localCapabilities.codecs.forEach(function(codec) {\\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\\n        // by adding level-asymmetry-allowed=1\\n        if (codec.name === 'H264' &&\\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\\n          codec.parameters['level-asymmetry-allowed'] = '1';\\n        }\\n      });\\n\\n      // generate an ssrc now, to be used later in rtpSender.send\\n      var sendEncodingParameters = [{\\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\\n      }];\\n      if (track) {\\n        // add RTX\\n        if (edgeVersion >= 15019 && kind === 'video') {\\n          sendEncodingParameters[0].rtx = {\\n            ssrc: (2 * sdpMLineIndex + 1) * 1001 + 1\\n          };\\n        }\\n      }\\n\\n      if (transceiver.wantReceive) {\\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\\n          transceiver.dtlsTransport,\\n          kind\\n        );\\n      }\\n\\n      transceiver.localCapabilities = localCapabilities;\\n      transceiver.sendEncodingParameters = sendEncodingParameters;\\n    });\\n\\n    // always offer BUNDLE and dispose on return if not supported.\\n    if (this._config.bundlePolicy !== 'max-compat') {\\n      sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) {\\n        return t.mid;\\n      }).join(' ') + '\\\\r\\\\n';\\n    }\\n    sdp += 'a=ice-options:trickle\\\\r\\\\n';\\n\\n    transceivers.forEach(function(transceiver, sdpMLineIndex) {\\n      sdp += SDPUtils.writeMediaSection(transceiver,\\n          transceiver.localCapabilities, 'offer', transceiver.stream);\\n      sdp += 'a=rtcp-rsize\\\\r\\\\n';\\n    });\\n\\n    this._pendingOffer = transceivers;\\n    var desc = new window.RTCSessionDescription({\\n      type: 'offer',\\n      sdp: sdp\\n    });\\n    if (arguments.length && typeof arguments[0] === 'function') {\\n      window.setTimeout(arguments[0], 0, desc);\\n    }\\n    return Promise.resolve(desc);\\n  };\\n\\n  RTCPeerConnection.prototype.createAnswer = function() {\\n    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId);\\n    if (this.usingBundle) {\\n      sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {\\n        return t.mid;\\n      }).join(' ') + '\\\\r\\\\n';\\n    }\\n    this.transceivers.forEach(function(transceiver, sdpMLineIndex) {\\n      if (transceiver.isDatachannel) {\\n        sdp += 'm=application 0 DTLS/SCTP 5000\\\\r\\\\n' +\\n            'c=IN IP4 0.0.0.0\\\\r\\\\n' +\\n            'a=mid:' + transceiver.mid + '\\\\r\\\\n';\\n        return;\\n      }\\n\\n      // FIXME: look at direction.\\n      if (transceiver.stream) {\\n        var localTrack;\\n        if (transceiver.kind === 'audio') {\\n          localTrack = transceiver.stream.getAudioTracks()[0];\\n        } else if (transceiver.kind === 'video') {\\n          localTrack = transceiver.stream.getVideoTracks()[0];\\n        }\\n        if (localTrack) {\\n          // add RTX\\n          if (edgeVersion >= 15019 && transceiver.kind === 'video') {\\n            transceiver.sendEncodingParameters[0].rtx = {\\n              ssrc: (2 * sdpMLineIndex + 2) * 1001 + 1\\n            };\\n          }\\n        }\\n      }\\n\\n      // Calculate intersection of capabilities.\\n      var commonCapabilities = getCommonCapabilities(\\n          transceiver.localCapabilities,\\n          transceiver.remoteCapabilities);\\n\\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\\n        return c.name.toLowerCase() === 'rtx';\\n      }).length;\\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\\n        delete transceiver.sendEncodingParameters[0].rtx;\\n      }\\n\\n      sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,\\n          'answer', transceiver.stream);\\n      if (transceiver.rtcpParameters &&\\n          transceiver.rtcpParameters.reducedSize) {\\n        sdp += 'a=rtcp-rsize\\\\r\\\\n';\\n      }\\n    });\\n\\n    var desc = new window.RTCSessionDescription({\\n      type: 'answer',\\n      sdp: sdp\\n    });\\n    if (arguments.length && typeof arguments[0] === 'function') {\\n      window.setTimeout(arguments[0], 0, desc);\\n    }\\n    return Promise.resolve(desc);\\n  };\\n\\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\\n    if (!candidate) {\\n      for (var j = 0; j < this.transceivers.length; j++) {\\n        this.transceivers[j].iceTransport.addRemoteCandidate({});\\n        if (this.usingBundle) {\\n          return Promise.resolve();\\n        }\\n      }\\n    } else {\\n      var mLineIndex = candidate.sdpMLineIndex;\\n      if (candidate.sdpMid) {\\n        for (var i = 0; i < this.transceivers.length; i++) {\\n          if (this.transceivers[i].mid === candidate.sdpMid) {\\n            mLineIndex = i;\\n            break;\\n          }\\n        }\\n      }\\n      var transceiver = this.transceivers[mLineIndex];\\n      if (transceiver) {\\n        var cand = Object.keys(candidate.candidate).length > 0 ?\\n            SDPUtils.parseCandidate(candidate.candidate) : {};\\n        // Ignore Chrome's invalid candidates since Edge does not like them.\\n        if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\\n          return Promise.resolve();\\n        }\\n        // Ignore RTCP candidates, we assume RTCP-MUX.\\n        if (cand.component &&\\n            !(cand.component === '1' || cand.component === 1)) {\\n          return Promise.resolve();\\n        }\\n        transceiver.iceTransport.addRemoteCandidate(cand);\\n\\n        // update the remoteDescription.\\n        var sections = SDPUtils.splitSections(this.remoteDescription.sdp);\\n        sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim()\\n            : 'a=end-of-candidates') + '\\\\r\\\\n';\\n        this.remoteDescription.sdp = sections.join('');\\n      }\\n    }\\n    if (arguments.length > 1 && typeof arguments[1] === 'function') {\\n      window.setTimeout(arguments[1], 0);\\n    }\\n    return Promise.resolve();\\n  };\\n\\n  RTCPeerConnection.prototype.getStats = function() {\\n    var promises = [];\\n    this.transceivers.forEach(function(transceiver) {\\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\\n        'dtlsTransport'].forEach(function(method) {\\n          if (transceiver[method]) {\\n            promises.push(transceiver[method].getStats());\\n          }\\n        });\\n    });\\n    var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&\\n        arguments[1];\\n    var fixStatsType = function(stat) {\\n      return {\\n        inboundrtp: 'inbound-rtp',\\n        outboundrtp: 'outbound-rtp',\\n        candidatepair: 'candidate-pair',\\n        localcandidate: 'local-candidate',\\n        remotecandidate: 'remote-candidate'\\n      }[stat.type] || stat.type;\\n    };\\n    return new Promise(function(resolve) {\\n      // shim getStats with maplike support\\n      var results = new Map();\\n      Promise.all(promises).then(function(res) {\\n        res.forEach(function(result) {\\n          Object.keys(result).forEach(function(id) {\\n            result[id].type = fixStatsType(result[id]);\\n            results.set(id, result[id]);\\n          });\\n        });\\n        if (cb) {\\n          window.setTimeout(cb, 0, results);\\n        }\\n        resolve(results);\\n      });\\n    });\\n  };\\n  return RTCPeerConnection;\\n};\\n\\n},{\\\"sdp\\\":1}],9:[function(require,module,exports){\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n'use strict';\\n\\nvar utils = require('../utils');\\n\\nvar firefoxShim = {\\n  shimOnTrack: function(window) {\\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\\n        window.RTCPeerConnection.prototype)) {\\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\\n        get: function() {\\n          return this._ontrack;\\n        },\\n        set: function(f) {\\n          if (this._ontrack) {\\n            this.removeEventListener('track', this._ontrack);\\n            this.removeEventListener('addstream', this._ontrackpoly);\\n          }\\n          this.addEventListener('track', this._ontrack = f);\\n          this.addEventListener('addstream', this._ontrackpoly = function(e) {\\n            e.stream.getTracks().forEach(function(track) {\\n              var event = new Event('track');\\n              event.track = track;\\n              event.receiver = {track: track};\\n              event.streams = [e.stream];\\n              this.dispatchEvent(event);\\n            }.bind(this));\\n          }.bind(this));\\n        }\\n      });\\n    }\\n  },\\n\\n  shimSourceObject: function(window) {\\n    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\\n    if (typeof window === 'object') {\\n      if (window.HTMLMediaElement &&\\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\\n          get: function() {\\n            return this.mozSrcObject;\\n          },\\n          set: function(stream) {\\n            this.mozSrcObject = stream;\\n          }\\n        });\\n      }\\n    }\\n  },\\n\\n  shimPeerConnection: function(window) {\\n    var browserDetails = utils.detectBrowser(window);\\n\\n    if (typeof window !== 'object' || !(window.RTCPeerConnection ||\\n        window.mozRTCPeerConnection)) {\\n      return; // probably media.peerconnection.enabled=false in about:config\\n    }\\n    // The RTCPeerConnection object.\\n    if (!window.RTCPeerConnection) {\\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\\n        if (browserDetails.version < 38) {\\n          // .urls is not supported in FF < 38.\\n          // create RTCIceServers with a single url.\\n          if (pcConfig && pcConfig.iceServers) {\\n            var newIceServers = [];\\n            for (var i = 0; i < pcConfig.iceServers.length; i++) {\\n              var server = pcConfig.iceServers[i];\\n              if (server.hasOwnProperty('urls')) {\\n                for (var j = 0; j < server.urls.length; j++) {\\n                  var newServer = {\\n                    url: server.urls[j]\\n                  };\\n                  if (server.urls[j].indexOf('turn') === 0) {\\n                    newServer.username = server.username;\\n                    newServer.credential = server.credential;\\n                  }\\n                  newIceServers.push(newServer);\\n                }\\n              } else {\\n                newIceServers.push(pcConfig.iceServers[i]);\\n              }\\n            }\\n            pcConfig.iceServers = newIceServers;\\n          }\\n        }\\n        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);\\n      };\\n      window.RTCPeerConnection.prototype =\\n          window.mozRTCPeerConnection.prototype;\\n\\n      // wrap static methods. Currently just generateCertificate.\\n      if (window.mozRTCPeerConnection.generateCertificate) {\\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\\n          get: function() {\\n            return window.mozRTCPeerConnection.generateCertificate;\\n          }\\n        });\\n      }\\n\\n      window.RTCSessionDescription = window.mozRTCSessionDescription;\\n      window.RTCIceCandidate = window.mozRTCIceCandidate;\\n    }\\n\\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\\n        .forEach(function(method) {\\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\\n          window.RTCPeerConnection.prototype[method] = function() {\\n            arguments[0] = new ((method === 'addIceCandidate') ?\\n                window.RTCIceCandidate :\\n                window.RTCSessionDescription)(arguments[0]);\\n            return nativeMethod.apply(this, arguments);\\n          };\\n        });\\n\\n    // support for addIceCandidate(null or undefined)\\n    var nativeAddIceCandidate =\\n        window.RTCPeerConnection.prototype.addIceCandidate;\\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\\n      if (!arguments[0]) {\\n        if (arguments[1]) {\\n          arguments[1].apply(null);\\n        }\\n        return Promise.resolve();\\n      }\\n      return nativeAddIceCandidate.apply(this, arguments);\\n    };\\n\\n    // shim getStats with maplike support\\n    var makeMapStats = function(stats) {\\n      var map = new Map();\\n      Object.keys(stats).forEach(function(key) {\\n        map.set(key, stats[key]);\\n        map[key] = stats[key];\\n      });\\n      return map;\\n    };\\n\\n    var modernStatsTypes = {\\n      inboundrtp: 'inbound-rtp',\\n      outboundrtp: 'outbound-rtp',\\n      candidatepair: 'candidate-pair',\\n      localcandidate: 'local-candidate',\\n      remotecandidate: 'remote-candidate'\\n    };\\n\\n    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;\\n    window.RTCPeerConnection.prototype.getStats = function(\\n      selector,\\n      onSucc,\\n      onErr\\n    ) {\\n      return nativeGetStats.apply(this, [selector || null])\\n        .then(function(stats) {\\n          if (browserDetails.version < 48) {\\n            stats = makeMapStats(stats);\\n          }\\n          if (browserDetails.version < 53 && !onSucc) {\\n            // Shim only promise getStats with spec-hyphens in type names\\n            // Leave callback version alone; misc old uses of forEach before Map\\n            try {\\n              stats.forEach(function(stat) {\\n                stat.type = modernStatsTypes[stat.type] || stat.type;\\n              });\\n            } catch (e) {\\n              if (e.name !== 'TypeError') {\\n                throw e;\\n              }\\n              // Avoid TypeError: \\\"type\\\" is read-only, in old versions. 34-43ish\\n              stats.forEach(function(stat, i) {\\n                stats.set(i, Object.assign({}, stat, {\\n                  type: modernStatsTypes[stat.type] || stat.type\\n                }));\\n              });\\n            }\\n          }\\n          return stats;\\n        })\\n        .then(onSucc, onErr);\\n    };\\n  }\\n};\\n\\n// Expose public methods.\\nmodule.exports = {\\n  shimOnTrack: firefoxShim.shimOnTrack,\\n  shimSourceObject: firefoxShim.shimSourceObject,\\n  shimPeerConnection: firefoxShim.shimPeerConnection,\\n  shimGetUserMedia: require('./getusermedia')\\n};\\n\\n},{\\\"../utils\\\":12,\\\"./getusermedia\\\":10}],10:[function(require,module,exports){\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n'use strict';\\n\\nvar utils = require('../utils');\\nvar logging = utils.log;\\n\\n// Expose public methods.\\nmodule.exports = function(window) {\\n  var browserDetails = utils.detectBrowser(window);\\n  var navigator = window && window.navigator;\\n  var MediaStreamTrack = window && window.MediaStreamTrack;\\n\\n  var shimError_ = function(e) {\\n    return {\\n      name: {\\n        InternalError: 'NotReadableError',\\n        NotSupportedError: 'TypeError',\\n        PermissionDeniedError: 'NotAllowedError',\\n        SecurityError: 'NotAllowedError'\\n      }[e.name] || e.name,\\n      message: {\\n        'The operation is insecure.': 'The request is not allowed by the ' +\\n        'user agent or the platform in the current context.'\\n      }[e.message] || e.message,\\n      constraint: e.constraint,\\n      toString: function() {\\n        return this.name + (this.message && ': ') + this.message;\\n      }\\n    };\\n  };\\n\\n  // getUserMedia constraints shim.\\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\\n    var constraintsToFF37_ = function(c) {\\n      if (typeof c !== 'object' || c.require) {\\n        return c;\\n      }\\n      var require = [];\\n      Object.keys(c).forEach(function(key) {\\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\\n          return;\\n        }\\n        var r = c[key] = (typeof c[key] === 'object') ?\\n            c[key] : {ideal: c[key]};\\n        if (r.min !== undefined ||\\n            r.max !== undefined || r.exact !== undefined) {\\n          require.push(key);\\n        }\\n        if (r.exact !== undefined) {\\n          if (typeof r.exact === 'number') {\\n            r. min = r.max = r.exact;\\n          } else {\\n            c[key] = r.exact;\\n          }\\n          delete r.exact;\\n        }\\n        if (r.ideal !== undefined) {\\n          c.advanced = c.advanced || [];\\n          var oc = {};\\n          if (typeof r.ideal === 'number') {\\n            oc[key] = {min: r.ideal, max: r.ideal};\\n          } else {\\n            oc[key] = r.ideal;\\n          }\\n          c.advanced.push(oc);\\n          delete r.ideal;\\n          if (!Object.keys(r).length) {\\n            delete c[key];\\n          }\\n        }\\n      });\\n      if (require.length) {\\n        c.require = require;\\n      }\\n      return c;\\n    };\\n    constraints = JSON.parse(JSON.stringify(constraints));\\n    if (browserDetails.version < 38) {\\n      logging('spec: ' + JSON.stringify(constraints));\\n      if (constraints.audio) {\\n        constraints.audio = constraintsToFF37_(constraints.audio);\\n      }\\n      if (constraints.video) {\\n        constraints.video = constraintsToFF37_(constraints.video);\\n      }\\n      logging('ff37: ' + JSON.stringify(constraints));\\n    }\\n    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {\\n      onError(shimError_(e));\\n    });\\n  };\\n\\n  // Returns the result of getUserMedia as a Promise.\\n  var getUserMediaPromise_ = function(constraints) {\\n    return new Promise(function(resolve, reject) {\\n      getUserMedia_(constraints, resolve, reject);\\n    });\\n  };\\n\\n  // Shim for mediaDevices on older versions.\\n  if (!navigator.mediaDevices) {\\n    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,\\n      addEventListener: function() { },\\n      removeEventListener: function() { }\\n    };\\n  }\\n  navigator.mediaDevices.enumerateDevices =\\n      navigator.mediaDevices.enumerateDevices || function() {\\n        return new Promise(function(resolve) {\\n          var infos = [\\n            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},\\n            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}\\n          ];\\n          resolve(infos);\\n        });\\n      };\\n\\n  if (browserDetails.version < 41) {\\n    // Work around http://bugzil.la/1169665\\n    var orgEnumerateDevices =\\n        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\\n    navigator.mediaDevices.enumerateDevices = function() {\\n      return orgEnumerateDevices().then(undefined, function(e) {\\n        if (e.name === 'NotFoundError') {\\n          return [];\\n        }\\n        throw e;\\n      });\\n    };\\n  }\\n  if (browserDetails.version < 49) {\\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\\n        bind(navigator.mediaDevices);\\n    navigator.mediaDevices.getUserMedia = function(c) {\\n      return origGetUserMedia(c).then(function(stream) {\\n        // Work around https://bugzil.la/802326\\n        if (c.audio && !stream.getAudioTracks().length ||\\n            c.video && !stream.getVideoTracks().length) {\\n          stream.getTracks().forEach(function(track) {\\n            track.stop();\\n          });\\n          throw new DOMException('The object can not be found here.',\\n                                 'NotFoundError');\\n        }\\n        return stream;\\n      }, function(e) {\\n        return Promise.reject(shimError_(e));\\n      });\\n    };\\n  }\\n  if (!(browserDetails.version > 55 &&\\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\\n    var remap = function(obj, a, b) {\\n      if (a in obj && !(b in obj)) {\\n        obj[b] = obj[a];\\n        delete obj[a];\\n      }\\n    };\\n\\n    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\\n        bind(navigator.mediaDevices);\\n    navigator.mediaDevices.getUserMedia = function(c) {\\n      if (typeof c === 'object' && typeof c.audio === 'object') {\\n        c = JSON.parse(JSON.stringify(c));\\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\\n      }\\n      return nativeGetUserMedia(c);\\n    };\\n\\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\\n      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;\\n      MediaStreamTrack.prototype.getSettings = function() {\\n        var obj = nativeGetSettings.apply(this, arguments);\\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\\n        return obj;\\n      };\\n    }\\n\\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\\n      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\\n        if (this.kind === 'audio' && typeof c === 'object') {\\n          c = JSON.parse(JSON.stringify(c));\\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\\n        }\\n        return nativeApplyConstraints.apply(this, [c]);\\n      };\\n    }\\n  }\\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\\n    if (browserDetails.version < 44) {\\n      return getUserMedia_(constraints, onSuccess, onError);\\n    }\\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\\n    console.warn('navigator.getUserMedia has been replaced by ' +\\n                 'navigator.mediaDevices.getUserMedia');\\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\\n  };\\n};\\n\\n},{\\\"../utils\\\":12}],11:[function(require,module,exports){\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n'use strict';\\nvar utils = require('../utils');\\n\\nvar safariShim = {\\n  // TODO: DrAlex, should be here, double check against LayoutTests\\n\\n  // TODO: once the back-end for the mac port is done, add.\\n  // TODO: check for webkitGTK+\\n  // shimPeerConnection: function() { },\\n\\n  shimLocalStreamsAPI: function(window) {\\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\\n      return;\\n    }\\n    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\\n      window.RTCPeerConnection.prototype.getLocalStreams = function() {\\n        if (!this._localStreams) {\\n          this._localStreams = [];\\n        }\\n        return this._localStreams;\\n      };\\n    }\\n    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {\\n      window.RTCPeerConnection.prototype.getStreamById = function(id) {\\n        var result = null;\\n        if (this._localStreams) {\\n          this._localStreams.forEach(function(stream) {\\n            if (stream.id === id) {\\n              result = stream;\\n            }\\n          });\\n        }\\n        if (this._remoteStreams) {\\n          this._remoteStreams.forEach(function(stream) {\\n            if (stream.id === id) {\\n              result = stream;\\n            }\\n          });\\n        }\\n        return result;\\n      };\\n    }\\n    if (!('addStream' in window.RTCPeerConnection.prototype)) {\\n      var _addTrack = window.RTCPeerConnection.prototype.addTrack;\\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\\n        if (!this._localStreams) {\\n          this._localStreams = [];\\n        }\\n        if (this._localStreams.indexOf(stream) === -1) {\\n          this._localStreams.push(stream);\\n        }\\n        var self = this;\\n        stream.getTracks().forEach(function(track) {\\n          _addTrack.call(self, track, stream);\\n        });\\n      };\\n\\n      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\\n        if (stream) {\\n          if (!this._localStreams) {\\n            this._localStreams = [stream];\\n          } else if (this._localStreams.indexOf(stream) === -1) {\\n            this._localStreams.push(stream);\\n          }\\n        }\\n        _addTrack.call(this, track, stream);\\n      };\\n    }\\n    if (!('removeStream' in window.RTCPeerConnection.prototype)) {\\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\\n        if (!this._localStreams) {\\n          this._localStreams = [];\\n        }\\n        var index = this._localStreams.indexOf(stream);\\n        if (index === -1) {\\n          return;\\n        }\\n        this._localStreams.splice(index, 1);\\n        var self = this;\\n        var tracks = stream.getTracks();\\n        this.getSenders().forEach(function(sender) {\\n          if (tracks.indexOf(sender.track) !== -1) {\\n            self.removeTrack(sender);\\n          }\\n        });\\n      };\\n    }\\n  },\\n  shimRemoteStreamsAPI: function(window) {\\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\\n      return;\\n    }\\n    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\\n      window.RTCPeerConnection.prototype.getRemoteStreams = function() {\\n        return this._remoteStreams ? this._remoteStreams : [];\\n      };\\n    }\\n    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\\n        get: function() {\\n          return this._onaddstream;\\n        },\\n        set: function(f) {\\n          if (this._onaddstream) {\\n            this.removeEventListener('addstream', this._onaddstream);\\n            this.removeEventListener('track', this._onaddstreampoly);\\n          }\\n          this.addEventListener('addstream', this._onaddstream = f);\\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\\n            var stream = e.streams[0];\\n            if (!this._remoteStreams) {\\n              this._remoteStreams = [];\\n            }\\n            if (this._remoteStreams.indexOf(stream) >= 0) {\\n              return;\\n            }\\n            this._remoteStreams.push(stream);\\n            var event = new Event('addstream');\\n            event.stream = e.streams[0];\\n            this.dispatchEvent(event);\\n          }.bind(this));\\n        }\\n      });\\n    }\\n  },\\n  shimCallbacksAPI: function(window) {\\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\\n      return;\\n    }\\n    var prototype = window.RTCPeerConnection.prototype;\\n    var createOffer = prototype.createOffer;\\n    var createAnswer = prototype.createAnswer;\\n    var setLocalDescription = prototype.setLocalDescription;\\n    var setRemoteDescription = prototype.setRemoteDescription;\\n    var addIceCandidate = prototype.addIceCandidate;\\n\\n    prototype.createOffer = function(successCallback, failureCallback) {\\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\\n      var promise = createOffer.apply(this, [options]);\\n      if (!failureCallback) {\\n        return promise;\\n      }\\n      promise.then(successCallback, failureCallback);\\n      return Promise.resolve();\\n    };\\n\\n    prototype.createAnswer = function(successCallback, failureCallback) {\\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\\n      var promise = createAnswer.apply(this, [options]);\\n      if (!failureCallback) {\\n        return promise;\\n      }\\n      promise.then(successCallback, failureCallback);\\n      return Promise.resolve();\\n    };\\n\\n    var withCallback = function(description, successCallback, failureCallback) {\\n      var promise = setLocalDescription.apply(this, [description]);\\n      if (!failureCallback) {\\n        return promise;\\n      }\\n      promise.then(successCallback, failureCallback);\\n      return Promise.resolve();\\n    };\\n    prototype.setLocalDescription = withCallback;\\n\\n    withCallback = function(description, successCallback, failureCallback) {\\n      var promise = setRemoteDescription.apply(this, [description]);\\n      if (!failureCallback) {\\n        return promise;\\n      }\\n      promise.then(successCallback, failureCallback);\\n      return Promise.resolve();\\n    };\\n    prototype.setRemoteDescription = withCallback;\\n\\n    withCallback = function(candidate, successCallback, failureCallback) {\\n      var promise = addIceCandidate.apply(this, [candidate]);\\n      if (!failureCallback) {\\n        return promise;\\n      }\\n      promise.then(successCallback, failureCallback);\\n      return Promise.resolve();\\n    };\\n    prototype.addIceCandidate = withCallback;\\n  },\\n  shimGetUserMedia: function(window) {\\n    var navigator = window && window.navigator;\\n\\n    if (!navigator.getUserMedia) {\\n      if (navigator.webkitGetUserMedia) {\\n        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\\n      } else if (navigator.mediaDevices &&\\n          navigator.mediaDevices.getUserMedia) {\\n        navigator.getUserMedia = function(constraints, cb, errcb) {\\n          navigator.mediaDevices.getUserMedia(constraints)\\n          .then(cb, errcb);\\n        }.bind(navigator);\\n      }\\n    }\\n  },\\n  shimRTCIceServerUrls: function(window) {\\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\\n    var OrigPeerConnection = window.RTCPeerConnection;\\n    window.RTCPeerConnection = function(pcConfig, pcConstraints) {\\n      if (pcConfig && pcConfig.iceServers) {\\n        var newIceServers = [];\\n        for (var i = 0; i < pcConfig.iceServers.length; i++) {\\n          var server = pcConfig.iceServers[i];\\n          if (!server.hasOwnProperty('urls') &&\\n              server.hasOwnProperty('url')) {\\n            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\\n            server = JSON.parse(JSON.stringify(server));\\n            server.urls = server.url;\\n            delete server.url;\\n            newIceServers.push(server);\\n          } else {\\n            newIceServers.push(pcConfig.iceServers[i]);\\n          }\\n        }\\n        pcConfig.iceServers = newIceServers;\\n      }\\n      return new OrigPeerConnection(pcConfig, pcConstraints);\\n    };\\n    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\\n    // wrap static methods. Currently just generateCertificate.\\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\\n      get: function() {\\n        return OrigPeerConnection.generateCertificate;\\n      }\\n    });\\n  }\\n};\\n\\n// Expose public methods.\\nmodule.exports = {\\n  shimCallbacksAPI: safariShim.shimCallbacksAPI,\\n  shimLocalStreamsAPI: safariShim.shimLocalStreamsAPI,\\n  shimRemoteStreamsAPI: safariShim.shimRemoteStreamsAPI,\\n  shimGetUserMedia: safariShim.shimGetUserMedia,\\n  shimRTCIceServerUrls: safariShim.shimRTCIceServerUrls\\n  // TODO\\n  // shimPeerConnection: safariShim.shimPeerConnection\\n};\\n\\n},{\\\"../utils\\\":12}],12:[function(require,module,exports){\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n'use strict';\\n\\nvar logDisabled_ = true;\\nvar deprecationWarnings_ = true;\\n\\n// Utility methods.\\nvar utils = {\\n  disableLog: function(bool) {\\n    if (typeof bool !== 'boolean') {\\n      return new Error('Argument type: ' + typeof bool +\\n          '. Please use a boolean.');\\n    }\\n    logDisabled_ = bool;\\n    return (bool) ? 'adapter.js logging disabled' :\\n        'adapter.js logging enabled';\\n  },\\n\\n  /**\\n   * Disable or enable deprecation warnings\\n   * @param {!boolean} bool set to true to disable warnings.\\n   */\\n  disableWarnings: function(bool) {\\n    if (typeof bool !== 'boolean') {\\n      return new Error('Argument type: ' + typeof bool +\\n          '. Please use a boolean.');\\n    }\\n    deprecationWarnings_ = !bool;\\n    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\\n  },\\n\\n  log: function() {\\n    if (typeof window === 'object') {\\n      if (logDisabled_) {\\n        return;\\n      }\\n      if (typeof console !== 'undefined' && typeof console.log === 'function') {\\n        console.log.apply(console, arguments);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Shows a deprecation warning suggesting the modern and spec-compatible API.\\n   */\\n  deprecated: function(oldMethod, newMethod) {\\n    if (!deprecationWarnings_) {\\n      return;\\n    }\\n    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\\n        ' instead.');\\n  },\\n\\n  /**\\n   * Extract browser version out of the provided user agent string.\\n   *\\n   * @param {!string} uastring userAgent string.\\n   * @param {!string} expr Regular expression used as match criteria.\\n   * @param {!number} pos position in the version string to be returned.\\n   * @return {!number} browser version.\\n   */\\n  extractVersion: function(uastring, expr, pos) {\\n    var match = uastring.match(expr);\\n    return match && match.length >= pos && parseInt(match[pos], 10);\\n  },\\n\\n  /**\\n   * Browser detector.\\n   *\\n   * @return {object} result containing browser and version\\n   *     properties.\\n   */\\n  detectBrowser: function(window) {\\n    var navigator = window && window.navigator;\\n\\n    // Returned result object.\\n    var result = {};\\n    result.browser = null;\\n    result.version = null;\\n\\n    // Fail early if it's not a browser\\n    if (typeof window === 'undefined' || !window.navigator) {\\n      result.browser = 'Not a browser.';\\n      return result;\\n    }\\n\\n    // Firefox.\\n    if (navigator.mozGetUserMedia) {\\n      result.browser = 'firefox';\\n      result.version = this.extractVersion(navigator.userAgent,\\n          /Firefox\\\\/(\\\\d+)\\\\./, 1);\\n    } else if (navigator.webkitGetUserMedia) {\\n      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now\\n      if (window.webkitRTCPeerConnection) {\\n        result.browser = 'chrome';\\n        result.version = this.extractVersion(navigator.userAgent,\\n          /Chrom(e|ium)\\\\/(\\\\d+)\\\\./, 2);\\n      } else { // Safari (in an unpublished version) or unknown webkit-based.\\n        if (navigator.userAgent.match(/Version\\\\/(\\\\d+).(\\\\d+)/)) {\\n          result.browser = 'safari';\\n          result.version = this.extractVersion(navigator.userAgent,\\n            /AppleWebKit\\\\/(\\\\d+)\\\\./, 1);\\n        } else { // unknown webkit-based browser.\\n          result.browser = 'Unsupported webkit-based browser ' +\\n              'with GUM support but no WebRTC support.';\\n          return result;\\n        }\\n      }\\n    } else if (navigator.mediaDevices &&\\n        navigator.userAgent.match(/Edge\\\\/(\\\\d+).(\\\\d+)$/)) { // Edge.\\n      result.browser = 'edge';\\n      result.version = this.extractVersion(navigator.userAgent,\\n          /Edge\\\\/(\\\\d+).(\\\\d+)$/, 2);\\n    } else if (navigator.mediaDevices &&\\n        navigator.userAgent.match(/AppleWebKit\\\\/(\\\\d+)\\\\./)) {\\n        // Safari, with webkitGetUserMedia removed.\\n      result.browser = 'safari';\\n      result.version = this.extractVersion(navigator.userAgent,\\n          /AppleWebKit\\\\/(\\\\d+)\\\\./, 1);\\n    } else { // Default fallthrough: not supported.\\n      result.browser = 'Not a supported browser.';\\n      return result;\\n    }\\n\\n    return result;\\n  },\\n\\n  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.\\n\\n  shimCreateObjectURL: function(window) {\\n    var URL = window && window.URL;\\n\\n    if (!(typeof window === 'object' && window.HTMLMediaElement &&\\n          'srcObject' in window.HTMLMediaElement.prototype)) {\\n      // Only shim CreateObjectURL using srcObject if srcObject exists.\\n      return undefined;\\n    }\\n\\n    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);\\n    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);\\n    var streams = new Map(), newId = 0;\\n\\n    URL.createObjectURL = function(stream) {\\n      if ('getTracks' in stream) {\\n        var url = 'polyblob:' + (++newId);\\n        streams.set(url, stream);\\n        utils.deprecated('URL.createObjectURL(stream)',\\n            'elem.srcObject = stream');\\n        return url;\\n      }\\n      return nativeCreateObjectURL(stream);\\n    };\\n    URL.revokeObjectURL = function(url) {\\n      nativeRevokeObjectURL(url);\\n      streams.delete(url);\\n    };\\n\\n    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,\\n                                              'src');\\n    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {\\n      get: function() {\\n        return dsc.get.apply(this);\\n      },\\n      set: function(url) {\\n        this.srcObject = streams.get(url) || null;\\n        return dsc.set.apply(this, [url]);\\n      }\\n    });\\n\\n    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;\\n    window.HTMLMediaElement.prototype.setAttribute = function() {\\n      if (arguments.length === 2 &&\\n          ('' + arguments[0]).toLowerCase() === 'src') {\\n        this.srcObject = streams.get(arguments[1]) || null;\\n      }\\n      return nativeSetAttribute.apply(this, arguments);\\n    };\\n  }\\n};\\n\\n// Export.\\nmodule.exports = {\\n  log: utils.log,\\n  deprecated: utils.deprecated,\\n  disableLog: utils.disableLog,\\n  disableWarnings: utils.disableWarnings,\\n  extractVersion: utils.extractVersion,\\n  shimCreateObjectURL: utils.shimCreateObjectURL,\\n  detectBrowser: utils.detectBrowser.bind(utils)\\n};\\n\\n},{}]},{},[2])(2)\\n});\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// C:/Users/Arnob/Downloads/webrtc-angularfire2-master/webrtc-angularfire2-master/angular/~/raw-loader!C:/Users/Arnob/Downloads/webrtc-angularfire2-master/webrtc-angularfire2-master/angular/~/webrtc-adapter/out/adapter.js\n// module id = ../../../../raw-loader/index.js!../../../../webrtc-adapter/out/adapter.js\n// module chunks = 3","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// C:/Users/Arnob/Downloads/webrtc-angularfire2-master/webrtc-angularfire2-master/angular/~/script-loader/addScript.js\n// module id = ../../../../script-loader/addScript.js\n// module chunks = 3","require(\"!!C:\\\\Users\\\\Arnob\\\\Downloads\\\\webrtc-angularfire2-master\\\\webrtc-angularfire2-master\\\\angular\\\\node_modules\\\\script-loader\\\\addScript.js\")(require(\"!!C:\\\\Users\\\\Arnob\\\\Downloads\\\\webrtc-angularfire2-master\\\\webrtc-angularfire2-master\\\\angular\\\\node_modules\\\\raw-loader\\\\index.js!C:\\\\Users\\\\Arnob\\\\Downloads\\\\webrtc-angularfire2-master\\\\webrtc-angularfire2-master\\\\angular\\\\node_modules\\\\webrtc-adapter\\\\out\\\\adapter.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// C:/Users/Arnob/Downloads/webrtc-angularfire2-master/webrtc-angularfire2-master/angular/~/script-loader!C:/Users/Arnob/Downloads/webrtc-angularfire2-master/webrtc-angularfire2-master/angular/~/webrtc-adapter/out/adapter.js\n// module id = ../../../../script-loader/index.js!../../../../webrtc-adapter/out/adapter.js\n// module chunks = 3"],"sourceRoot":"webpack:///"}